\section{Approach 3: Inspired by total energy}\label{sec:CtrlApproachEnergy}
The previous approaches for the design of a closed loop also motived a total energy $\totalEnergyC$.
Unfortunately, it did, in general, not turn out to be useful for stability analysis.
In this section we like to motivate yet another approach for the design of a closed loop dynamics for the tracking problem which is based on the total energy as Lyapunov function.

\subsection{Overall structure}
The general structure of this approach follows \cite{Bullo:TrackingAutomatica}.

\paragraph*{Total energy.}
Initially we drop the rigid body structure of the system and only consider the coordinates $\sysCoord, \sysVel$ and their kinematic relation $\sysCoordd = \kinMat(\sysCoord) \sysVel$.
Define the ``total error energy'' as
\begin{align}\label{eq:DefTotalErrorEnergy}
 \totalEnergyC(\sysCoord, \sysVel, \sysCoordR, \sysVelR) = \underbrace{\tfrac{1}{2} \norm[\sysInertiaMatC(\sysCoord)]{\overbrace{\sysVel-\sysTransportMap(\sysCoord, \sysCoordR)\sysVelR}^{\sysVelE}}^2}_{\kineticEnergyC} \ + \ \potentialEnergyC(\sysCoord, \sysCoordR)
\end{align}
with the positive definite error potential $\potentialEnergyC: \configSpace \times \configSpace \rightarrow \RealNumP$, $\potentialEnergyC(\sysCoord, \sysCoordR) = 0 \ \Leftrightarrow \ \sysCoord = \sysCoordR$ and the positive definite inertia matrix $\sysInertiaMatC(\sysCoord)\in\SymMatP(\dimConfigSpace)$.
So far the transport map $\sysTransportMap: \configSpace \times \configSpace \rightarrow \RealNum^{\dimConfigSpace\times\dimConfigSpace}$ may be any regular matrix with $\sysTransportMap(\sysCoord, \sysCoord) = \idMat[\dimConfigSpace]$.
Combination of these requirements yields the positive definiteness of the total energy, i.e.
\begin{align}
 \totalEnergyC(\sysCoord, \sysVel, \sysCoordR, \sysVelR) \geq 0, \quad \totalEnergyC(\sysCoord, \sysVel, \sysCoordR, \sysVelR) = 0 \ \Leftrightarrow \ \sysCoord = \sysCoordR,\, \sysVel = \sysVelR.
\end{align}

\paragraph{Change of total energy.}
The time derivative of the total energy is
\begin{align}
% \totalEnergyCd &= \sysVelCoeffE{\LidxI}\big( \sysInertiaMatCoeff{\LidxI\LidxII} \sysVelCoeffEd{\LidxII} + \dirDiff{\LidxIII} \sysInertiaMatCoeff{\LidxI\LidxII} \sysVelCoeff{\LidxIII} \sysVelCoeffE{\LidxII} \big) + \sysVelCoeff{\LidxI} \dirDiff{\LidxI}\potentialEnergyC + \sysVelCoeffR{\LidxI} \dirDiffR{\LidxI}\potentialEnergyC.
 \totalEnergyCd &= \sysVelE^\top \big( \sysInertiaMatC \sysVelEd + \tfrac{1}{2}\sysInertiaMatCd \sysVelE \big) + \sysVel^\top \differential\potentialEnergyC + \sysVelR^\top \differentialR\potentialEnergyC.
\nonumber\\
\label{eq:CtrlApprochEnergyBalanceOfEnergyFirst}
% &= \sysVelCoeffE{\LidxI} \big( \sysInertiaMatCoeff{\LidxI\LidxII} \sysVelCoeffEd{\LidxII} + \dirDiff{\LidxIII} \sysInertiaMatCoeff{\LidxI\LidxII} \sysVelCoeff{\LidxIII} \sysVelCoeffE{\LidxII} + \sysVelCoeff{\LidxI} \dirDiff{\LidxI}\potentialEnergyC \big) + \sysVelCoeffR{\LidxI} ( \dirDiffR{\LidxI}\potentialEnergyC + \sysTransportMapCoeff{\LidxII}{\LidxI} \dirDiff{\LidxII}\potentialEnergyC).
 &= \sysVelE^\top \big( \sysInertiaMatC \sysVelEd + \tfrac{1}{2}\sysInertiaMatCd \sysVelE + \differential\potentialEnergyC \big) + \sysVelR^\top \big( \differentialR\potentialEnergyC + \sysTransportMap^\top \differential\potentialEnergyC \big).
\end{align}
%where $\dirDiffR{\LidxI} = \kinMatCoeff{\GidxI}{\LidxI}(\sysCoordR)\tpdiff{\sysCoordCoeffR{\GidxI}}$
where $\differentialR = \kinMat^\top(\sysCoordR) \tpdiff{\sysCoordR}$.
The second term vanishes if we require the transport map $\sysTransportMap$ to fulfill 
\begin{align}\label{eq:ReqTransportMap}
 \differentialR\potentialEnergyC = -\sysTransportMap^\top \differential\potentialEnergyC.
\end{align}
With a positive definite damping matrix $\sysDissMatC \in \SymMatP(\dimConfigSpace)$ and a yet to define skew symmetric matrix $\accCtrl{\mat{S}} = -\accCtrl{\mat{S}}^\top \in \RealNum^{\dimConfigSpace\times\dimConfigSpace}$ we set the closed loop kinetics as
\begin{align}\label{eq:CtrlApprochEnergyKineticsFirst}
 \sysInertiaMatC \sysVelEd + \tfrac{1}{2}\sysInertiaMatCd \sysVelE + \differential\potentialEnergyC = -(\sysDissMatC + \accCtrl{\mat{S}})\sysVelE.
\end{align}
Plugging the closed loop kinetics \eqref{eq:CtrlApprochEnergyKineticsFirst} and the requirement on the transport map \eqref{eq:ReqTransportMap} into the change of energy \eqref{eq:CtrlApprochEnergyBalanceOfEnergyFirst} we obtain
\begin{align}
 \totalEnergyCd = -\sysVelE^\top \sysDissMatC \sysVelE = -\norm[\sysDissMatC]{\sysVelE}^2.
\end{align}
Since $\tdiff{t} \totalEnergyC$ is only negative semidefinite, we can only conclude stability but not attractiveness.
One can pursue the prove of attractiveness by adding a cross term as done in \cite[sec.\ 4.2]{Bullo:TrackingAutomatica}.

\paragraph{Covariance of the closed loop.}
The skew symmetric matrix $\accCtrl{\mat{S}}$ cancels out in the balance of energy, so is of no interest for tuning purposes.
Instead it is used to ensure that the closed loop \eqref{eq:CtrlApprochEnergyKineticsFirst} is \textit{covariant}, i.e.\ its definition is unchanged under a change of coordinates.
While the stiffness force $\genForceStiffCoeffC{\LidxI} = \dirDiff{\LidxI} \potentialEnergyC$ and the dissipative force $\genForceDissCoeffC{\LidxI} = \sysDissMatCoeffC{\LidxI\LidxII} \sysVelCoeffE{\LidxII}$ are tensors, the inertia force $\genForceInertiaCoeffC{\LidxI} = \sysInertiaMatCoeffC{\LidxI\LidxII} \sysVelCoeffEd{\LidxII} + \tfrac{1}{2} \dirDiff{\LidxIII} \sysInertiaMatCoeffC{\LidxI\LidxII} \sysVelCoeff{\LidxIII} \sysVelCoeffE{\LidxII} + \accCtrl{S}_{\LidxI\LidxII} \sysVelCoeffE{\LidxII}$ is not.
A universal way is to derive a transformation law and put it as an additional requirement for the closed loop.
This would still not lead to a unique definition for $\accCtrl{\mat{S}}$.

However, regarding $\sysInertiaMatCoeffC{\LidxI\LidxII}$ as the coefficients of a Riemannian metric, there are the coefficients of the unique Levi Civita connection already encountered in \eqref{eq:DefConnCoeffL}:
\begin{align}
 \ConnCoeffLC{\LidxI}{\LidxII}{\LidxIII} &= \tfrac{1}{2}\big( \partial_\LidxIII \sysInertiaMatCoeffC{\LidxI\LidxII} + \partial_\LidxII \sysInertiaMatCoeffC{\LidxI\LidxIII} - \partial_\LidxI \sysInertiaMatCoeffC{\LidxII\LidxIII} + \BoltzSym{\LidxV}{\LidxI}{\LidxII} \sysInertiaMatCoeffC{\LidxV\LidxIII} + \BoltzSym{\LidxV}{\LidxI}{\LidxIII} \sysInertiaMatCoeffC{\LidxV\LidxII} - \BoltzSym{\LidxV}{\LidxII}{\LidxIII} \sysInertiaMatCoeffC{\LidxV\LidxI} \big),
\quad
 \LidxI, \LidxII, \LidxIII = 1,\ldots,\dimConfigSpace
 .
\end{align}
This motivates the inertia force in the clearly covariant form
\begin{align}
 \genForceInertiaCoeffC{\LidxI} = \sysInertiaMatCoeffC{\LidxI\LidxII} \sysVelCoeffEd{\LidxII} + \ConnCoeffLC{\LidxI}{\LidxII}{\LidxIII}\sysVelCoeff{\LidxIII} \sysVelCoeffE{\LidxII}.
\end{align}
It may be realized by setting $\accCtrl{S}_{\LidxI\LidxII} = \ConnCoeffLC{\LidxI}{\LidxII}{\LidxIII}\sysVelCoeff{\LidxIII} - \tfrac{1}{2}\sysInertiaMatCoeffCd{\LidxI\LidxII} = \tfrac{1}{2}(\ConnCoeffLC{\LidxI}{\LidxII}{\LidxIII} - \ConnCoeffLC{\LidxII}{\LidxI}{\LidxIII})\sysVelCoeff{\LidxIII} = -\accCtrl{S}_{\LidxII\LidxI}$ in \eqref{eq:CtrlApprochEnergyKineticsFirst}.


%\begin{RedBox}
%The desired error kinetics for the energy based approach have the form
%\begin{align}\label{eq:desiredErrorKineticsEnergy}
% \underbrace{\sysInertiaMatCoeffC{\LidxI\LidxII} \sysVelCoeffEd{\LidxII} + \ConnCoeffLC{\LidxI}{\LidxII}{\LidxIII} \sysVelCoeff{\LidxIII} \sysVelCoeffE{\LidxII}}_{\genForceInertiaCoeffC{\LidxI}}
% + \underbrace{\sysDissMatCoeffC{\LidxI\LidxII} \sysVelCoeffE{\LidxII}}_{\genForceDissCoeffC{\LidxI}}
% + \underbrace{\dirDiff{\LidxI} \potentialEnergyC}_{\genForceStiffCoeffC{\LidxI}}
%  &= 0,
% \qquad
%  \LidxI = 1,\ldots,\dimConfigSpace.
% \end{align}
% \end{RedBox}

% \paragraph{Explicit control law.}
% The closed loop \eqref{eq:desiredErrorKinetics} can be written in a similar form as the model
% \begin{align}\label{eq:desiredErrorKineticsMatrix}
%  \sysInertiaMatC \sysVeld + \genForceC = 0 
% \end{align}
% where
% \begin{align}
% % \genForceCoeffC{\LidxI} = -\sysInertiaMatCoeffC{\LidxI\LidxII} \big( \sysTransportMapCoeff{\LidxII}{\LidxIII} \sysVelCoeffRd{\LidxIII} + \sysTransportMapCoeffd{\LidxII}{\LidxIII} \sysVelCoeffR{\LidxIII} \big)
%  \genForceCoeffC{\LidxI} = -\sysInertiaMatCoeffC{\LidxI\LidxII} \big( \sysTransportMapCoeff{\LidxII}{\LidxIII} \sysVelCoeffRd{\LidxIII} + \dirDiff{\LidxIV} \sysTransportMapCoeff{\LidxII}{\LidxIII} \sysVelCoeff{\LidxIV} \sysVelCoeffR{\LidxIII} + \dirDiffR{\LidxIV} \sysTransportMapCoeff{\LidxII}{\LidxIII} \sysVelCoeffR{\LidxIV} \sysVelCoeffR{\LidxIII} \big)
%  + \big( \ConnCoeffLC{\LidxI}{\LidxII}{\LidxIII} \sysVelCoeff{\LidxIII} + \sysDissMatCoeffC{\LidxI\LidxII} \big) \big( \sysVelCoeff{\LidxII} - \sysTransportMapCoeff{\LidxII}{\LidxIV} \sysVelCoeffR{\LidxIV} \big)
%  + \dirDiff{\LidxI} \potentialEnergyC
% \end{align}
% Finally, plugging the acceleration $\sysVeld$ from the desired closed loop \eqref{eq:desiredErrorKineticsMatrix} into the model (??) we get the required control law
% \begin{align}\label{eq:ExplicitControlLawFully}
%  \sysInput = \sysInputMat^{-1} \big( \genForce - \sysInertiaMat \sysInertiaMatC^{-1} \genForceC \big).
% \end{align}

\subsection{Special cases}\label{sec:ComputedTorque}
\paragraph{Euclidean space.}
The existing literature on control of mechanical systems uses almost exclusively minimal generalized coordinates $\genCoord \in \RealNum^\dimConfigSpace$ and the velocity coordinates $\genCoordd$.
Then the model can we written as
\begin{align}
 \sysInertiaMat(\genCoord) \genCoorddd + \ConnMat(\genCoord, \genCoordd) \genCoordd = \genForceImpressed 
\end{align}
where $\ConnMatCoeff{\LidxI\LidxII} = \ConnCoeffL{\LidxI}{\LidxII}{\LidxIII}\sysVelCoeff{\LidxIII}$ and $\genForceImpressed$ collects the remaining forces.
For a fully actuated system there exists an input transformation such that $\genForceImpressed$ can be regarded as virtual inputs.

On the Euclidean space $\RealNum^\dimConfigSpace$ it is reasonable to introduce error coordinates $\genCoordE = \genCoord - \genCoordR$ and to use a quadratic error potential
\begin{align}\label{eq:EuclideanMetricPotential}
 \potentialEnergyC = \tfrac{1}{2} \genCoordE^\top \sysStiffMatC \genCoordE, \qquad \sysStiffMatC \in \SymMatP(\dimConfigSpace).
\end{align}
This error potential obviously has the transport map $\sysTransportMap = \idMat[\dimConfigSpace]$ and the resulting error velocity $\sysVelE = \genCoordEd = \genCoordd - \genCoordRd$.
Furthermore it is reasonable to choose a constant dissipation matrix $\sysDissMatC \in \SymMatP(\dimConfigSpace)$.

\paragraph{Joint PD-Control.}
Choosing the desired inertia identical to the model inertia $\sysInertiaMatC = \sysInertiaMat$, which also implies $\ConnMatC = \ConnMat$, yields the closed loop kinetics
\begin{align}
 \sysInertiaMat(\genCoord) \genCoordEdd + \ConnMat(\genCoord, \genCoordd) \genCoordEd + \sysDissMatC \genCoordEd + \sysStiffMatC \genCoordE = \tuple{0}.
\end{align}
The resulting control law is
\begin{align}
 \genForceImpressed = \sysInertiaMat(\genCoord) \genCoordRdd + \ConnMat(\genCoord, \genCoordd) \genCoordRd - \sysDissMatC \genCoordEd - \sysStiffMatC \genCoordE.
\end{align} 
This approach is commonly called \textit{joint proportional derivative controller} \cite[sec.\,9.1.1]{Slotine:AppliedNonlinearControl} or \textit{augmented PD control law} \cite[sec.\,4.5.3]{Murray:Robotic}, \cite[sec.\,8.2]{Spong:RobotModelingAndControl}.

\paragraph{Computed torque.}
Choosing the desired inertia as $\sysInertiaMatC = \idMat[{\dimConfigSpace}]$, which implies $\ConnMatC = \mat{0}$ leads to the closed loop kinetics
\begin{align}
 \genCoordEdd + \sysDissMatC \genCoordEd + \sysStiffMatC \genCoordE = \tuple{0}.
\end{align}
The resulting control law is
\begin{align}
 \genForceImpressed = \sysInertiaMat(\genCoord) \big( \genCoordRdd - \sysDissMatC \genCoordEd - \sysStiffMatC \genCoordE \big) + \ConnMat(\genCoord, \genCoordd) \genCoordd.
\end{align}
This approach is commonly called \textit{computed torque} \cite[sec.\,4.5.2]{Murray:Robotic}, \cite[sec.\,9.1.2]{Slotine:AppliedNonlinearControl} or \textit{inverse dynamics control} \cite[sec.\,8.3]{Spong:RobotModelingAndControl}.

These well established approaches are contained within the derived framework.
However, as argued in the introduction of this chapter, the use of the Euclidean metric \eqref{eq:EuclideanMetricPotential} only makes sense if the configuration space is indeed an Euclidean space.
Application of this approach to e.g.\ the rigid body orientation would lead to quite awkward motion.


\subsection{Free rigid body}\label{sec:CtrlApproachEnergySingleBody}
Consider a single free rigid body as extensively discussed in \autoref{sec:RB}.
We use the position $\r$ and orientation $\R$ combined in the matrix $\bodyHomoCoord{}{} \in \SpecialEuclideanGroup(3)$ as configuration coordinates and the linear velocity $\v = \R^\top \rd$ and angular velocity $\w = \veeOp(\R^\top \Rd)$ combined in $[\v^\top, \w^\top]^\top = \bodyVel{}{} = \veeOp(\bodyHomoCoord{}{}^{-1} \bodyHomoCoordd{}{})$ as velocity coordinates.

\paragraph{Potential and transport map.}
As for the previous approaches, a reasonable choice (motivated from linear springs in \autoref{sec:RBStiffness}) for the potential energy for a rigid body is
\begin{align}\label{eq:PotentialRigidBodyAppOne}
 \potentialEnergyC = \tfrac{1}{2} \norm[\bodyStiffMatCp{}{}]{ (\bodyHomoCoord{}{} - \bodyHomoCoordR{}{} )^\top}^2,
\qquad
 \bodyStiffMatCp{}{} \in \SymMatP(4).
\end{align}
The time derivative of the potential is
\begin{align}\label{eq:TimeDerivativeRigidBodxPotential}
 \dot{\potentialEnergyC} &= \tr \big( (\bodyHomoCoord{}{} - \bodyHomoCoordR{}{}) \bodyStiffMatCp{}{} (\bodyHomoCoord{}{} \wedOp(\bodyVel{}{}) - \bodyHomoCoordR{}{} \wedOp(\bodyVelR{}{}))^\top \big)
 \nonumber\\
 &= \tr \big( (\idMat[4] - \bodyHomoCoord{}{}^{-1}\bodyHomoCoordR{}{}) \bodyStiffMatCp{}{} \wedOp(\bodyVel{}{} - \Ad{\bodyHomoCoord{}{}^{-1}\bodyHomoCoordR{}{}} \bodyVelR{}{})^\top \big)
\nonumber\\
 &= \underbrace{(\bodyVel{}{} - \Ad{\bodyHomoCoord{}{}^{-1}\bodyHomoCoordR{}{}} \bodyVelR{}{})}_{\sysVelE}\vphantom{|}^\top \underbrace{\veeTwoOp\big( (\idMat[4] - \bodyHomoCoord{}{}^{-1}\bodyHomoCoordR{}{}) \bodyStiffMatCp{}{} \big)}_{\differential \potentialEnergyC}.
\end{align}
Recalling the identity $\differential \potentialEnergyC = \spdiff[\dot{\potentialEnergyC}]{\sysVel}$, it is evident that $\sysTransportMap = \Ad{\bodyHomoCoord{}{}^{-1}\bodyHomoCoordR{}{}}$ is a transport map for this potential
\footnote{
It should be noted that the transport map given in \eqref{eq:TimeDerivativeRigidBodxPotential} is not unique.
One can check by direct calculation that the following matrix also fulfills the required relation \eqref{eq:ReqTransportMap}:
\begin{align}\label{eq:RigidBodyAlternativeTransportMap}
 \sysTransportMap = \begin{bmatrix} \R^\top\RR & \wedOp\hc\,\R^\top\RR - \R^\top\RR \wedOp\hc \\ \mat{0} & \R^\top\RR \end{bmatrix}.
\end{align}
}
.
The potential $\potentialEnergyC$ and the resulting force $\genForceStiffC = \differential \potentialEnergyC $ coincides with the ones given for the previous approaches, already explicitly stated in \eqref{eq:GenForceStiffRigidBodyCtrl}.
% \begin{align}\label{eq:TransportMapRigidBody}
%  \differentialR \potentialEnergyC = \tpdiff[\dot{\potentialEnergyC}]{\bodyVelR{}{}}
%  = -(\Ad{\bodyHomoCoord{}{}^{-1}\bodyHomoCoordR{}{}})^\top \tpdiff[\dot{\potentialEnergyC}]{\bodyVel{}{}}
%  = -(\Ad{\bodyHomoCoord{}{}^{-1}\bodyHomoCoordR{}{}})^\top \differential \potentialEnergyC.
% \end{align}

% As motivated in \autoref{sec:RB}, the stiffness matrix $\bodyStiffMatCp{}{}$ can be assembled from the (controlled) body stiffness $\kc \in \RealNum^+$, center of stiffness $\hc \in \RealNum^3$ and the moment of stiffness $\kapc \in \SymMatP(3)$.
% Then the stiffness force can be written as
% \begin{align}
%  \bodyStiffMatCp{}{} &= \begin{bmatrix} \wedMatOp\kapc & \kc \hc \\ \kc \hc^\top & \kc \end{bmatrix},&
%  \genForceStiff &= \differential \potentialEnergyC =
%  \begin{bmatrix}
%   \kc \R^\top(\r\!-\!\rR) + (\idMat[4] \!-\! \R^\top \RR) \kc\hc \\
%   \wedOp(\kc \hc) \R^\top (\r\!-\!\rR) + \veeTwoOp\big( \wedMatOp\kapc \, \RR^\top \R \big)
%  \end{bmatrix}
% \end{align}

\paragraph{Damping.}
Using the same damping matrix $\sysDissMatC = \veeMatOp\bodyDissMatCp{}{}$ with $\bodyDissMatCp{}{} \in \SymMatP(4)$ as with the body based approach, we find the same damping force \eqref{eq:RBCtrlBodyDiss}. 


\paragraph{Inertia.}
Using the same inertia matrix as for the body based approach $\sysInertiaMatC = \veeMatOp\bodyInertiaMatCp{}{}$ with $\bodyInertiaMatCp{}{} \in \SymMatP(4)$ we find the controlled inertial force $\genForceInertiaC$ as
\begin{align}\label{eq:RBCtrlEnergy}
 \genForceInertiaC
 &= \underbrace{\begin{bmatrix} \mc \idMat[3] & \!\!\mc (\wedOp\sc)^\top \\ \mc \wedOp\sc & \Jc \end{bmatrix}}_{\sysInertiaMatC} \underbrace{\begin{bmatrix} \vEd \\ \wEd \end{bmatrix}}_{\sysVelEd}
 +  \underbrace{\begin{bmatrix} \mc \wedOp\w & -\mc \wedOp\w \wedOp\sc \\ \mc \wedOp\sc \wedOp\w & \wedOp(\wedMatOp\Jc\,\w) \end{bmatrix}}_{\ConnMatC(\sysVel) = -\ConnMatC^\top\!(\sysVel)} \underbrace{\begin{bmatrix} \vE \\ \wE \end{bmatrix}}_{\sysVelE}.
\end{align}
This result is similar to the previous body based approach \eqref{eq:ClosedLoopRBApproach2}, only differing by replacing $\ConnMatC(\sysVel)$ with $\ConnMatC(\sysVelE)$.
Consequently with this approach the closed loop dynamics are not autonomous.

% \paragraph{Error coordinates and velocity.}
% Since the norm in \eqref{eq:PotentialRigidBodyAppOne} is invariant to left translation of the argument, it can be stated as
% \begin{align}
%  \potentialEnergyC = \tfrac{1}{2} \norm[\bodyStiffMatCp{}{}]{ (\underbrace{\bodyHomoCoordR{}{}^{-1}\bodyHomoCoord{}{}}_{\bodyHomoCoordE{}{}} - \idMat[4] )^\top}^2,
% \end{align}
% and the \textit{configuration error} $\bodyHomoCoordE{}{} = \bodyHomoCoordR{}{}^{-1}\bodyHomoCoord{}{} \in \SpecialEuclideanGroup(3)$ can be regarded as redundant error coordinates.
% Furthermore, the velocity is associated with the configuration error coincides with the error velocity $\sysVelE$ defined through the transport map in \eqref{eq:TransportMapRigidBody}:
% \begin{align}
%  \bodyVelE{}{} = \veeOp\big( \bodyHomoCoordE{}{}^{-1} \bodyHomoCoordEd{}{} \big) 
% % = \veeOp\big( \bodyHomoCoord{}{}^{-1}\bodyHomoCoordR{}{} \bodyHomoCoordR{}{}^{-1}\bodyHomoCoord{}{} \wedOp\bodyVel{}{} - \bodyHomoCoord{}{}^{-1}\bodyHomoCoordR{}{} \wedOp\bodyVelR{}{} \bodyHomoCoordR{}{}^{-1}\bodyHomoCoord{}{}  \big)
% % = \veeOp\big( \wedOp\bodyVel{}{} - \bodyHomoCoord{}{}^{-1}\bodyHomoCoordR{}{} \wedOp\bodyVelR{}{} \bodyHomoCoordR{}{}^{-1}\bodyHomoCoord{}{}  \big)
%  = \veeOp\big( \wedOp\bodyVel{}{} - \bodyHomoCoordE{}{}^{-1} \wedOp\bodyVelR{}{} \bodyHomoCoordE{}{}^{-1}  \big)
%  = \bodyVel{}{} - \Ad{\bodyHomoCoordE{}{}^{-1}} \bodyVelR{}{}.
% \end{align}
% The explicit relations for the position $\rE$ and orientation error $\RE$ and their velocities $\vE$, $\wE$ are
% \begin{align}
%  \underbrace{\begin{bmatrix} \RE & \rE \\ \mat{0} & 1 \end{bmatrix}}_{\bodyHomoCoordE{}{}} 
%  &= \underbrace{\begin{bmatrix} \RR^\top \R & \RR^\top (\r - \rR) \\ \mat{0} & 1 \end{bmatrix}}_{\bodyHomoCoordR{}{}^{-1}\bodyHomoCoord{}{}},&
% %  &= \underbrace{\begin{bmatrix} \RR^\top & -\RR^\top \rR \\ \mat{0} & 1 \end{bmatrix}}_{\bodyHomoCoordR{}{}^{-1}} 
% %  \underbrace{\begin{bmatrix} \R & \r \\ \mat{0} & 1 \end{bmatrix}}_{\bodyHomoCoord{}{}}
%  \underbrace{\begin{bmatrix} \vE \\ \wE \end{bmatrix}}_{\bodyVelE{}{}} 
%  &= \underbrace{\begin{bmatrix} \v \\ \w \end{bmatrix}}_{\bodyVel{}{}} 
%  - \underbrace{\begin{bmatrix} \RE^\top & -\RE^\top \wedOp\rE \\ \mat{0} & \RE^\top \end{bmatrix}}_{\Ad{\bodyHomoCoordE{}{}^{-1}}} 
%  \underbrace{\begin{bmatrix} \vR \\ \wR \end{bmatrix}}_{\bodyVelR{}{}}.
% \end{align}

% \paragraph{An alternative transport map.}
% It should be noted that the transport map given in \eqref{eq:TimeDerivativeRigidBodxPotential} is not unique.
% One can check by direct calculation that the following matrix also fulfills the required relation \eqref{eq:ReqTransportMap}:
% \begin{align}\label{eq:RigidBodyAlternativeTransportMap}
%  \sysTransportMap = \begin{bmatrix} \R^\top\RR & \wedOp\hc\,\R^\top\RR - \R^\top\RR \wedOp\hc \\ \mat{0} & \R^\top\RR \end{bmatrix}.
% \end{align}

% \paragraph{Linearization.}
% For a small deviation of the system state to its reference, the error can be captured by $\LinErrorCoord_r(t), \LinErrorCoord_R(t) \in \RealNum^3$.
% A first order approximation of the system dynamics is
% \begin{subequations}
% \begin{align}
%  \r \approx \rR + \RR \LinErrorCoord_r,
% \quad 
%  \R \approx \RR + \RR \wedOp\LinErrorCoord_R,
% \\
%  \underbrace{\begin{bmatrix} \v \\ \w \end{bmatrix}}_{\sysVel} 
%  \approx \underbrace{\begin{bmatrix} \vR \\ \wR \end{bmatrix}}_{\sysVelR}
%  + \underbrace{\begin{bmatrix} \LinErrorCoordd_r \\ \LinErrorCoordd_R \end{bmatrix}}_{\LinErrorCoordd}
%  + \underbrace{\begin{bmatrix} \wedOp\wR & \wedOp\vR \\ \mat{0} & \wedOp\wR \end{bmatrix}}_{\ad{\sysVelR}} \underbrace{\begin{bmatrix} \LinErrorCoord_r \\ \LinErrorCoord_R \end{bmatrix}}_{\LinErrorCoord},
% \\
% %  \LinErrorCoord = [\LinErrorCoord_r^\top, \LinErrorCoord_R^\top]^\top,
% % \quad
%  \sysInertiaMatC \LinErrorCoorddd + \big( \sysDissMatC + \ConnMatC(\sysVelR) \big) \LinErrorCoordd + \sysStiffMatC \LinErrorCoord = \tuple{0}.
% \end{align}
% \end{subequations}

\subsection{Rigid body systems}\label{sec:CtrlApproachEnergyRBS}
As for the previous approaches we use the rigid body structure, i.e.\ the configurations $\bodyHomoCoord{\BidxI}{\BidxII}(\sysCoord)$ and velocities $\bodyVel{\BidxI}{\BidxII}(\sysCoord, \sysVel) = \bodyJac{\BidxI}{\BidxII}(\sysCoord) \sysVel$, as inspiration for controlled kinetics.
Assigning stiffness, damping and inertia $\bodyStiffMatCp{\BidxI}{\BidxII}, \bodyDissMatCp{\BidxI}{\BidxII}, \bodyInertiaMatCp{\BidxI}{\BidxII} \in \SymMatSP(4)$ to each absolute and relative configuration leads to the following potential energy $\potentialEnergyC$, damping $\sysDissMatC$ and inertia matrix $\sysInertiaMatC$:
\begin{RedBox}
\begin{subequations}\label{eq:CtrlApproachEnergyRBS}
\begin{align}
 \potentialEnergyC(\sysCoord,\sysCoordR) &= \sumBodiesAB \tfrac{1}{2} \norm[\bodyStiffMatCp{\BidxI}{\BidxII}]{(\bodyHomoCoord{\BidxI}{\BidxII}(\sysCoord) - \bodyHomoCoord{\BidxI}{\BidxII}(\sysCoordR))^\top}^2,&
 \bodyStiffMatCp{\BidxI}{\BidxII} &\in \SymMatSP(4)
 \label{eq:GenForceStiffControlEnergy}
\\
 \sysDissMatC(\sysCoord) &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top(\sysCoord) \, \veeMatOp(\bodyDissMatCp{\BidxI}{\BidxII}) \bodyJac{\BidxI}{\BidxII}(\sysCoord),&
 \bodyDissMatCp{\BidxI}{\BidxII} &\in \SymMatSP(4)
\\
 \sysInertiaMatC(\sysCoord) &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top(\sysCoord) \, \veeMatOp(\bodyInertiaMatCp{\BidxI}{\BidxII}) \bodyJac{\BidxI}{\BidxII}(\sysCoord),&
 \bodyInertiaMatCp{\BidxI}{\BidxII} &\in \SymMatSP(4)
\end{align} 
\end{subequations}
\end{RedBox}
Note that the body matrices do not have to be positive definite, only the resulting system matrices and the potential have to be positive definite to ensure stability.

\paragraph{Transport map.}
The potential $\potentialEnergyC$ and the resulting force $\differential \potentialEnergyC$ are identical to the previous approaches, see e.g.\ \eqref{eq:GenForceStiffControlParticles}.
For this energy based approach we require the existence of a transport map.
The condition \eqref{eq:ReqTransportMap} for the transport map $\sysTransportMap$ with the given potential \eqref{eq:GenForceStiffControlEnergy} may be expanded to
\begin{align}
%\sum_{\BidxI, \BidxII} \big( \bodyJac{\BidxI}{\BidxII}(\sysCoord) \sysTransportMap(\sysCoord, \sysCoordR) - \Ad{\bodyHomoCoord{\BidxI}{\BidxII}^{-1}(\sysCoord)\, \bodyHomoCoord{\BidxI}{\BidxII}(\sysCoordR)} \bodyJac{\BidxI}{\BidxII}(\sysCoordR)\big)^\top \bodyGenForceStiffC{\BidxI}{\BidxII}(\sysCoord, \sysCoordR) &= \tuple{0}.
 \sumBodiesAB \big( \bodyJac{\BidxI}{\BidxII} \sysTransportMap - \Ad{\bodyHomoCoordE{\BidxI}{\BidxII}^{-1}} \bodyJacR{\BidxI}{\BidxII}\big)^\top \veeTwoOp\big((\idMat[4]-\bodyHomoCoordE{\BidxI}{\BidxI}^{-1})\bodyStiffMatCp{\BidxI}{\BidxII}\big) &= \tuple{0}.
\end{align}
with the shorthand notation $\bodyHomoCoordE{\BidxI}{\BidxII} = \bodyHomoCoord{\BidxI}{\BidxII}^{-1}(\sysCoordR) \bodyHomoCoordE{\BidxI}{\BidxII}(\sysCoord)$ and $\bodyJacR{\BidxI}{\BidxII} = \bodyJac{\BidxI}{\BidxII}(\sysCoordR)$.
There is no general solution for this, the transport map $\sysTransportMap$ has to be computed for each example individually.
A major caveat of this approach is that there is no general guaranty on the existence of a transport map.

