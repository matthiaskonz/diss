\section{Summary and recipe}

\begin{figure}
 \centering
 \newcommand{\macSysCoord}{$\sysCoord, \sysVel, \kinMat$}
 \newcommand{\macBodyCoord}{$\{\bodyHomoCoord{\BidxI}{\BidxII}\}$}
 \newcommand{\macPlantParamOne}{$\{\bodyInertiaMat{0}{\BidxII}, \bodyDissMat{\BidxI}{\BidxII}, \bodyStiffMat{\BidxI}{\BidxII}\}$}
 \newcommand{\macPlantParamTwo}{$\{\bodyHomoCoord{\BidxI}{\BidxII}_0\}, \gravityAcc$}
 \newcommand{\macCtrlParamOne}{$\{\bodyInertiaMatC{\BidxI}{\BidxII}, \bodyDissMatC{\BidxI}{\BidxII}, \bodyStiffMatC{\BidxI}{\BidxII}\}$}
 \newcommand{\macCtrlParamTwo}{$\sysCoordR, \sysVelR, \sysVelRd$}
 \newcommand{\macBodyJac}{$\{\bodyHomoCoord{\BidxI}{\BidxII}, \bodyJac{\BidxI}{\BidxII}, \bodyJacd{\BidxI}{\BidxII}\}$}
 \newcommand{\macPlantKineticsMats}{$\sysInertiaMat, \sysForce, \sysInputMat$}
 \newcommand{\macClosedLoopKineticsMats}{$\sysInertiaMatC, \sysForceC$}
 \newcommand{\macCtrlOut}{$\sysInput_0$}
 \newcommand{\macMatchingOut}{$\tuple{\lambda}$}
 \newcommand{\macMatchingIn}{$\sysInputMatLComp$}
 \newcommand{\macTransportMapIn}{$\sysTransportMap$}
 \newcommand{\macTotalEnergyOut}{$\totalEnergyC$}
 \input{graphics/CtrlSummaryBlock.pdf_tex}
 \caption{Computation of the RBS controller}
 \label{fig:CtrlSummaryBlock}
\end{figure}

This chapter motivated three approaches for desired closed loop dynamics for the tracking control task for rigid body systems.
The complete procedure for computing the resulting controller may be summarized in \autoref{fig:CtrlSummaryBlock} and as follows:
\begin{enumerate}
\item \textbf{RBS kinematics.}
Let the rigid body system be parameterized by a set of absolute or relative configurations $\{\bodyHomoCoord{\BidxI}{\BidxII}\}$ formulated in terms of the chosen coordinates $\sysCoord$ as discussed in \autoref{sec:RBSParameterization}.
Let change of configuration coordinates be captured by the system velocity $\sysVel$ such that $\sysCoordd = \kinMat \sysVel$ as discussed in \autoref{sec:secMathMinVelCoord}.
Given these ingredients, we may use the rules from \autoref{sec:RBSParameterization} to compute any relative configurations $\{\bodyHomoCoord{\BidxI}{\BidxII}\}$ and the corresponding body Jacobians $\{\bodyJac{\BidxI}{\BidxII}\}$.

\item \textbf{Model kinetics.}
The computation of the model kinetics $\sysInertiaMat \sysVeld + \sysForce = \sysInputMat \sysInput$ from the kinematic terms $\{\bodyHomoCoord{\BidxI}{\BidxII}, \bodyJac{\BidxI}{\BidxII}, \bodyJacd{\BidxI}{\BidxII}\}$ and the constitutive parameters $\{\bodyInertiaMat{0}{\BidxII}, \bodyDissMat{\BidxI}{\BidxII}, \bodyStiffMat{\BidxI}{\BidxII}, \bodyHomoCoord{\BidxI}{\BidxII}_0\}$ and $\gravityAcc$ was already summarized in \autoref{sec:MechRBSSummary}.

\item \textbf{Desired kinetics.}
The terms $\sysInertiaMatC, \sysForceC$ of the desired kinetics $\sysInertiaMatC\sysVeld + \sysForceC=\tuple{0}$ are computed by the particle based approach \eqref{eq:CtrlApproachParticles}, the body based approach \eqref{eq:CtrlApproachBody} or the energy based approach \eqref{eq:CtrlApproachEnergyRBS}.
In each case they are completely determined by the kinematic terms $\{\bodyHomoCoord{\BidxI}{\BidxII}, \bodyJac{\BidxI}{\BidxII}, \bodyJacd{\BidxI}{\BidxII}\}$, the desired rigid body parameters $\{\bodyInertiaMatC{\BidxI}{\BidxII}, \bodyDissMatC{\BidxI}{\BidxII}, \bodyStiffMatC{\BidxI}{\BidxII}\}$ and the reference trajectory $t\mapsto(\sysCoordR, \sysVelR, \sysVelRd)(t)$.
Only the energy based approach requires additionally a transport map $\sysVel$.

Furthermore, these ingredients determine the total energy $\totalEnergyC$ that may be regarded as a metric of how good the tracking task is fulfilled.
For the energy based approach it is a Lyapunov function.

\item \textbf{Compute controller.}
The actual control $\sysInput = \sysInput_0$ is computed from the model and the desired kinematics as discussed in \autoref{sec:CtrlUnderactuated}.
For the fully actuated case ($\rank\sysInputMat=\dimConfigSpace$) the desired kinetics are realized exactly. 

For the underactuated case ($\rank\sysInputMat<\dimConfigSpace$) the control input is computed such that the resulting system acceleration $\sysVeld$ deflects the least from the desired acceleration $-\sysInertiaMatC^{-1}\sysForceC$ in the least squares sense withe the weights $\sysInertiaMatC$.
For a given left complement $\sysInputMatLComp$ we may also compute the matching force $\tuple{\lambda}$ which gives insight in how to adjust the control parameters $\{\bodyInertiaMatC{\BidxI}{\BidxII}, \bodyDissMatC{\BidxI}{\BidxII}, \bodyStiffMatC{\BidxI}{\BidxII}\}$ to minimize or eliminate this deflection.

\end{enumerate}


% We have proposed three approaches for a control law for rigid body systems.
% Each of them formulated a sightly different template for the desired closed loop dynamics.
% The actual control law results from its combination with the model dynamics.
% For a fully actuated system the desired closed loop is achieved exactly.
% For an underactuated system or in the presence of input constraints one achieves closed loop dynamics that are ``as close as possible`` to the desired dynamics in the sense that the resulting acceleration differs in the least squares sense.

% The implementation of the controller is determined by the rigid body parameterization $\bodyHomoCoord{\BidxI}{\BidxII}(\sysCoord)$, the kinematics $\sysCoordd = \kinMat(\sysCoord) \sysVel$ and the \textit{desired} constitutive parameters $\bodyInertiaMatC{\BidxI}{\BidxII}$, $\bodyDissMatC{\BidxI}{\BidxII}$, $\bodyStiffMatC{\BidxI}{\BidxII}$.
% It is crucial to note that the resulting controlled system is invariant to the chosen coordinates $\sysCoord, \sysVel$ in the same way as the system model:
% Though the describing equations depend explicitly on the coordinates, the resulting motion of the closed loop system is the same for any choice of coordinates.
% This can be validated by checking the covariance of the closed loop equations.

% What does affect the motion of the controlled system are the constitutive parameters, i.e. the values within $\bodyInertiaMatC{\BidxI}{\BidxII}$, $\bodyDissMatC{\BidxI}{\BidxII}$, $\bodyStiffMatC{\BidxI}{\BidxII}$.
% These are associated with the rigid bodies and are completely independent of the system coordinates.
% For the energy based approach, the choice of a transport map might not be unique and consequently might also affect the motion.

% \newcommand{\configErr}[2]{\JokerTensor[^{#1}_{#2}]{\mat{\mathsf{E}}}{}}
% \newcommand{\configErrd}[2]{\JokerTensor[^{#1}_{#2}]{\dot{\mat{\mathsf{E}}}}{}}
% \newcommand{\configErrdd}[2]{\JokerTensor[^{#1}_{#2}]{\ddot{\mat{\mathsf{E}}}}{}}
% 
% \begin{figure}[p]
%  \centering
%  \newcommand{\macModelCoordAndKin}{$\sysCoord(t) \in \configSpace, \, \sysVel(t) \in \RealNum^{\dimConfigSpace}, \ \sysCoordd = \kinMat(\sysCoord) \sysVel$}
%  \newcommand{\macRigidBodyStructure}{$\bodyHomoCoord{\BidxI}{\BidxII}(\sysCoord) \in \SpecialEuclideanGroup(3), \, \BidxI, \BidxII = 0,\ldots,\numRigidBodies$}
%  \newcommand{\macKineticEquation}{$\sysInertiaMat(\sysCoord) \sysVeld + \genForce(\sysCoord, \sysVel) = \sysInputMat(\sysCoord) \sysInput, \ \sysInputConstMat \sysInput \leq \sysInputConstVec$}
%  \newcommand{\macPotentialAppOne}{$\potentialEnergyC = \sum_{\BidxI, \BidxII} \tfrac{1}{2} \norm[\bodyStiffMatCp{\BidxI}{\BidxII}]{(\bodyHomoCoord{\BidxI}{\BidxII} - \bodyHomoCoordR{\BidxI}{\BidxII})^\top}^2$}
%  \newcommand{\macDissMatAppOne}{$\sysDissMatC = \sum_{\BidxI, \BidxII} \bodyJac{\BidxI}{\BidxII}^\top \veeMatOp(\bodyDissMatCp{\BidxI}{\BidxII}) \bodyJac{\BidxI}{\BidxII}$}
%  \newcommand{\macInertiaMatAppOne}{$\sysInertiaMatC = \sum_{\BidxI, \BidxII} \bodyJac{\BidxI}{\BidxII}^\top \veeMatOp(\bodyInertiaMatCp{\BidxI}{\BidxII}) \bodyJac{\BidxI}{\BidxII}$}
%  \newcommand{\macTransportMap}{$\differentialR \potentialEnergyC = -\sysTransportMap^\top \differential \potentialEnergyC$}
%  \newcommand{\macVelError}{$\sysVelE = \sysVel - \sysTransportMap \sysVelR$}
% % \newcommand{\macKineticEquationAppOne}{$\sysInertiaMatCoeffC{\LidxI\LidxII} \sysVelCoeffEd{\LidxII} + \ConnCoeffLC{\LidxI}{\LidxII}{\LidxIII} \sysVelCoeff{\LidxIII} \sysVelCoeffE{\LidxII} + \sysDissMatCoeffC{\LidxI\LidxII} \sysVelCoeffE{\LidxII} + \dirDiff{\LidxI} \potentialEnergyC = 0$}
%  \newcommand{\macKineticEquationAppOne}{$\sysInertiaMatC \sysVelEd + \ConnMatC \sysVelE + \sysDissMatC \sysVelE + \differential \potentialEnergyC = \tuple{0}$}
%  \newcommand{\macBodyConfigErrorAppTwo}{$\configErr{\BidxI}{\BidxII} = \bodyHomoCoord{\BidxI}{\BidxII} - \bodyHomoCoordR{\BidxI}{\BidxII}$}
%  \newcommand{\macBodyConfigErrorAppThree}{$\configErr{\BidxI}{\BidxII} = \bodyHomoCoordR{\BidxI}{\BidxII}^{-1} \bodyHomoCoord{\BidxI}{\BidxII} - \idMat[4]$}
%  \newcommand{\macPotentialAppTwo}{$\potentialEnergyC = \sum_{\BidxI, \BidxII} \tfrac{1}{2} \norm[\bodyStiffMatCp{\BidxI}{\BidxII}]{\configErr{\BidxI}{\BidxII}^\top}^2$}
%  \newcommand{\macDissFktAppTwo}{$\dissFktC = \sum_{\BidxI, \BidxII} \tfrac{1}{2} \norm[\bodyDissMatCp{\BidxI}{\BidxII}]{\configErrd{\BidxI}{\BidxII}^\top}^2$}
%  \newcommand{\macAccEnergyAppTwo}{$\accEnergyC = \sum_{\BidxI, \BidxII} \tfrac{1}{2} \norm[\bodyInertiaMatCp{\BidxI}{\BidxII}]{\configErrdd{\BidxI}{\BidxII}^\top}^2$}
%  \newcommand{\macKineticEquationAppTwo}{$\pdiff[\accEnergyC]{\sysVeld} + \pdiff[\dissFktC]{\sysVel} + \differential\potentialEnergyC = \tuple{0}$}
%  \newcommand{\macKineticEquationC}{$\sysInertiaMatC(\sysCoord) \sysVeld + \genForceC(\sysCoord, \sysVel, \sysCoordR, \sysVel, \sysVelR) = \tuple{0}$}
%  %\newcommand{\macCtrlStaticMin}{$\begin{array}{rl}\text{minimize} & \norm[\mat{H}]{\sysInput - \sysInput_0}^2 \\ \text{subject to} &\sysInputConstMat \sysInput \leq \sysInputConstVec \end{array}$}
%  \newcommand{\macCtrlStaticMin}{$\sysInput = \argmin \norm[\mat{H}]{\sysInput - \sysInput_0}^2, \, \text{s.t.}\, \sysInputConstMat \sysInput \leq \sysInputConstVec$}
%  \newcommand{\macCtrlEqI}{$\mat{H} = \sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC \sysInertiaMat^{-1} \sysInputMat$}
%  \newcommand{\macCtrlEqII}{$\sysInput_0 = \mat{H}^{-1} \sysInputMat^\top \sysInertiaMat^{-1} (\sysInertiaMatC \sysInertiaMat^{-1} \genForce - \genForceC)$}
%  \newcommand{\macKonstParam}{$\bodyStiffMatCp{\BidxI}{\BidxII}, \bodyDissMatCp{\BidxI}{\BidxII}, \bodyInertiaMatCp{\BidxI}{\BidxII} \in \SymMatP(4), \, \BidxI, \BidxII = 0,\ldots,\numRigidBodies$}
%  \input{graphics/CtrlApproachSummary.pdf_tex}
%  \caption{Summary of the control design procedure}
%  \label{fig:CtrlApproachSummary}
% \end{figure}

% \paragraph*{THE recipe:}
% % Let the rigid body system under consideration be parameterized by the (possibly redundant) coordinates $\sysCoord(t)\in\configSpace$.
% % This means that we can express all configurations of its individual rigid bodies by $\bodyHomoCoord{\BidxI}{\BidxII} : \configSpace \rightarrow \SpecialEuclideanGroup(3) : \sysCoord \mapsto \bodyHomoCoord{\BidxI}{\BidxII}(\sysCoord)$.
% \begin{itemize}
% \item Modeling: 
% A recipe for the derivation of the equations of motion of a rigid body system was given in \autoref{sec:MechRBSSummary}:
%  \begin{itemize}\begin{subequations}
%   \item Choose a set of (possibly redundant) configuration coordinates $\sysCoord(t)\in\configSpace = \{ \sysCoord\in\RealNum^\numCoord \, | \, \geoConstraint(\sysCoord) = \tuple{0} \}$ and minimal velocity coordinates $\sysVel(t) \in \RealNum^{\dimConfigSpace}$, $\dimConfigSpace=\dim\configSpace$ that are related by the kinematics matrix $\kinMat(\sysCoord)\in\RealNum^{\numCoord\times\dimConfigSpace}$:
%   \begin{align}
%    \sysCoordd = \kinMat \sysVel   
%   \end{align}
%   \item Formulate the rigid body configurations $\bodyHomoCoord{\BidxI}{\BidxII}(\sysCoord) \in \SpecialEuclideanGroup(3), \, \BidxI, \BidxII = 0,\ldots,\numRigidBodies$ in terms of the chosen coordinates.
%   This determines the body Jacobians
%   \begin{align}
%    \bodyJac{\BidxI}{\BidxII} &= \tpdiff{\sysCoordd} \veeOp\big( \bodyHomoCoord{\BidxI}{\BidxII}^{-1} \bodyHomoCoordd{\BidxI}{\BidxII} \big) \kinMat
%   \end{align}
%   \item Compute the model inertia force $\genForceInertia = \sysInertiaMat \sysVeld + \gyroForce$ from the body inertias $\bodyInertiaMatp{0}{\BidxII}$ (see \autoref{sec:RBSInertia})
%   \begin{align}
%    \sysInertiaMat \!=\! \sumBodies \bodyJac{0}{\BidxII}^\top \veeMatOp(\bodyInertiaMatp{0}{\BidxII}) \bodyJac{0}{\BidxII},
%    \
%    \gyroForce \!=\! \sumBodies \bodyJac{0}{\BidxII}^\top \big(\veeMatOp(\bodyInertiaMatp{0}{\BidxII}) \bodyJacd{0}{\BidxII} - \ad{\bodyJac{0}{\BidxII}\sysVel}^\top \veeMatOp(\bodyInertiaMatp{0}{\BidxII})\bodyJac{0}{\BidxII} \big) \sysVel
%   \end{align}
%   \item The model kinetics are the balance of the inertia force $\genForceInertia$, the force of control inputs $\sysInputMat \sysInput$ and whatever other forces $\genForceImpressed$ may act on the system
%   \begin{align}
%    \sysInertiaMat \sysVeld + \underbrace{\gyroForce + \genForceImpressed}_{\sysForce} = \sysInputMat \sysInput
%   \end{align}
%  \end{subequations}\end{itemize}
%  \item Closed loop template
%  \begin{itemize}\begin{subequations}
%   \item The template is computed from the body configurations $\bodyHomoCoord{\BidxI}{\BidxII}$, the body Jacobians $\bodyJac{\BidxI}{\BidxII}$ and the control parameters $\bodyStiffMatCp{\BidxI}{\BidxII}, \bodyDissMatCp{\BidxI}{\BidxII}, \bodyInertiaMatCp{\BidxI}{\BidxII}$:
%   \begin{align}
%    \sysInertiaMatC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeMatOp(\bodyInertiaMatCp{\BidxI}{\BidxII}) \bodyJac{\BidxI}{\BidxII}
%   \\
%    \genForceStiffC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeTwoOp \big( (\idMat[4] - \bodyHomoCoordE{\BidxI}{\BidxII}^{-1}) \bodyStiffMatCp{\BidxI}{\BidxII} \big)
%   \end{align}
%   \item particle-based approach (see \autoref{sec:CtrlApproachParticlesRBS})
%   \begin{align}
%    \genForceDissC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeTwoOp \big(\big( \wedOp(\bodyJac{\BidxI}{\BidxII}(\sysCoord) \sysVel) - \bodyHomoCoordE{\BidxI}{\BidxII}^{-1} \wedOp(\bodyJac{\BidxI}{\BidxII}(\sysCoordR) \sysVelR) \big) \bodyDissMatCp{\BidxI}{\BidxII} \big)
%   \\
%    \gyroForceC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeTwoOp \big(\big( \wedOp(\bodyJacd{\BidxI}{\BidxII} \sysVel) + \wedOp(\bodyJac{\BidxI}{\BidxII} \sysVel)^2
%    \nonumber\\ &\hspace{4em} -\bodyHomoCoordE{\BidxI}{\BidxII}^{-1} \big( \wedOp(\bodyJacR{\BidxI}{\BidxII}\sysVelRd + \bodyJacRd{\BidxI}{\BidxII} \sysVelR) + \wedOp(\bodyJacR{\BidxI}{\BidxII} \sysVelR)^2 \big) \big) \bodyInertiaMatCp{\BidxI}{\BidxII} \big)
%   \end{align}
%   \item body-based approach (see \autoref{sec:CtrlApproachBodyRBS})
%   \begin{align}
%    \genForceDissC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeMatOp(\bodyDissMatCp{\BidxI}{\BidxII})\bodyVelE{\BidxI}{\BidxII}, \qquad \bodyVelE{\BidxI}{\BidxII} = \bodyJac{\BidxI}{\BidxII} \sysVel - \Ad{\bodyHomoCoordE{\BidxI}{\BidxII}^{-1}} \bodyJacR{\BidxI}{\BidxII} \sysVelR, 
%   \\
%    \gyroForceC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \big( \bodyInertiaMatC{\BidxI}{\BidxII} (\bodyJacd{\BidxI}{\BidxII} \sysVel - \Ad{\bodyHomoCoordE{\BidxI}{\BidxII}^{-1}} (\bodyJacR{\BidxI}{\BidxII} \sysVelRd + \bodyJacRd{\BidxI}{\BidxII} \sysVelR) + \ad{\bodyVelE{\BidxI}{\BidxII}} \Ad{\bodyHomoCoordE{\BidxI}{\BidxII}^{-1}} \bodyJacR{\BidxI}{\BidxII} \sysVelR)
%    \nonumber\\ &\hspace{20em} -\ad{\bodyVelE{\BidxI}{\BidxII}}^\top \bodyInertiaMatC{\BidxI}{\BidxII} \bodyVelE{\BidxI}{\BidxII} \big), 
%   \end{align}
%   \item energy-based approach (see \autoref{sec:CtrlApproachEnergyRBS}, requires the choice of a transport map $\sysTransportMap$)
%   \begin{align}
%    \genForceDissC &= \sysDissMatC \sysVelE, 
%   \quad
%    \sysDissMatC = \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeMatOp(\bodyDissMatCp{\BidxI}{\BidxII}) \bodyJac{\BidxI}{\BidxII},
%   \quad 
%    \sysVelE = \sysVel - \sysTransportMap \sysVelR
%   \\
%    \ConnMatC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \big( \veeMatOp(\bodyInertiaMatCp{\BidxI}{\BidxII}) \bodyJacd{\BidxI}{\BidxII} + \bodyConnMatC{\BidxI}{\BidxII} \bodyJac{\BidxI}{\BidxII} \big), \quad \bodyConnMatCoeffC{\BidxI}{\BidxII}{\LBidxI}{\LBidxII} = \bodyConnFkt{\LBidxI}{\LBidxII}{\LBidxIII}(\bodyInertiaMatCp{\BidxI}{\BidxII}) \bodyJacCoeff{\BidxI}{\BidxII}{\LBidxIII}{\LidxIII} \sysVelCoeff{\LidxIII}
%   \\
%    \gyroForceC &= \ConnMatC \sysVelE - \sysInertiaMatC(\sysTransportMap\sysVelRd + \sysTransportMapd\sysVelR),
%   \end{align}
%   \item The desired closed loop kinetics are
%   \begin{align}
%    \sysInertiaMatC \sysVeld + \underbrace{\gyroForceC + \genForceDissC + \genForceStiffC}_{\sysForceC} = \tuple{0}
%   \end{align}
%  \end{subequations}\end{itemize}
%  \item Control law:
%  \begin{itemize}\begin{subequations}
%   \item For the fully actuated case, the desired closed loop is realized by  
%   \begin{align}
%    \sysInput = \sysInputMat^{-1} (\sysForce - \sysInertiaMat \sysInertiaMatC^{-1}\sysForceC)
%   \end{align}
%   \item In the underactuated case, the acceleration error measured by the Gaussian constraint, is minimized by (see \autoref{sec:CtrlUnderactuatedOptim})
%   \begin{align}
%    \sysInput &= (\sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC \sysInertiaMat^{-1} \sysInputMat)^{-1} \sysInputMat^\top \sysInertiaMat^{-1} (\sysInertiaMatC \sysInertiaMat^{-1} \sysForce - \sysForceC)
%   \end{align}
%   Choosing an orthogonal complement $\sysInputMatLComp$ to the input matrix $\sysInputMat$, i.e.\ $\rank \sysInputMatLComp = \dimConfigSpace-\numInputs$ and $\sysInputMat^\top \sysInputMatLComp = \mat{0}$, the residual acceleration error can be written as $\GaussianConstraintC_0 = \tfrac{1}{2} \norm[\mat{S}]{\tuple{\lambda}}^2$ where (see \autoref{sec:MatchingCondition})
%   \begin{align}
%    \tuple{\lambda} = (\sysInputMatLComp)^\top (\sysInertiaMat \sysInertiaMatC^{-1} \sysForceC - \sysForce) = \tuple{0},
%    \qquad
%    \mat{S} = \big( (\sysInputMatLComp)^\top \sysInertiaMat \sysInertiaMatC^{-1} \sysInertiaMat \sysInputMatLComp \big)^{-1}
%   \end{align}
%   By adjusting the control parameters within $\sysInertiaMatC$ and $\sysForceC$ one may try to minimize $\GaussianConstraintC_0$.
%  \end{subequations}\end{itemize}
% \end{itemize}
