\section{Summary and recipe}
We have proposed three approaches for a control law for rigid body systems.
Each of them formulated a sightly different template for the desired closed loop dynamics.
The actual control law results from its combination with the model dynamics.
For a fully actuated system the desired closed loop is achieved exactly.
For an underactuated system or in the presence of input constraints one achieves closed loop dynamics that are ``as close as possible`` to the desired dynamics in the sense that the resulting acceleration differs the least.

The implementation of the controller is determined by the rigid body parameterization $\bodyHomoCoord{\BidxI}{\BidxII}(\sysCoord)$, the kinematics $\sysCoordd = \kinMat(\sysCoord) \sysVel$ and the \textit{desired} constitutive parameters $\bodyInertiaMatC{\BidxI}{\BidxII}$, $\bodyDissMatC{\BidxI}{\BidxII}$, $\bodyStiffMatC{\BidxI}{\BidxII}$.
It is crucial to note that the resulting controlled system is invariant to the chosen coordinates $\sysCoord, \sysVel$ in the same way as the system model:
Though the describing equations depend explicitly on the coordinates, the resulting motion of the closed loop system is the same for any choice of coordinates.
This can be validated by checking the covariance of the closed loop equations.

What does affect the motion of the controlled system are the constitutive parameters, i.e. the values within $\bodyInertiaMatC{\BidxI}{\BidxII}$, $\bodyDissMatC{\BidxI}{\BidxII}$, $\bodyStiffMatC{\BidxI}{\BidxII}$.
These are associated with the rigid bodies and are completely independent of the system coordinates.
For the energy based approach, the choice of a transport map might not be unique and consequently might also affect the motion.

% \newcommand{\configErr}[2]{\JokerTensor[^{#1}_{#2}]{\mat{\mathsf{E}}}{}}
% \newcommand{\configErrd}[2]{\JokerTensor[^{#1}_{#2}]{\dot{\mat{\mathsf{E}}}}{}}
% \newcommand{\configErrdd}[2]{\JokerTensor[^{#1}_{#2}]{\ddot{\mat{\mathsf{E}}}}{}}
% 
% \begin{figure}[p]
%  \centering
%  \newcommand{\macModelCoordAndKin}{$\sysCoord(t) \in \configSpace, \, \sysVel(t) \in \RealNum^{\dimConfigSpace}, \ \sysCoordd = \kinMat(\sysCoord) \sysVel$}
%  \newcommand{\macRigidBodyStructure}{$\bodyHomoCoord{\BidxI}{\BidxII}(\sysCoord) \in \SpecialEuclideanGroup(3), \, \BidxI, \BidxII = 0,\ldots,\numRigidBodies$}
%  \newcommand{\macKineticEquation}{$\sysInertiaMat(\sysCoord) \sysVeld + \genForce(\sysCoord, \sysVel) = \sysInputMat(\sysCoord) \sysInput, \ \sysInputConstMat \sysInput \leq \sysInputConstVec$}
%  \newcommand{\macPotentialAppOne}{$\potentialEnergyC = \sum_{\BidxI, \BidxII} \tfrac{1}{2} \norm[\bodyStiffMatCp{\BidxI}{\BidxII}]{(\bodyHomoCoord{\BidxI}{\BidxII} - \bodyHomoCoordR{\BidxI}{\BidxII})^\top}^2$}
%  \newcommand{\macDissMatAppOne}{$\sysDissMatC = \sum_{\BidxI, \BidxII} \bodyJac{\BidxI}{\BidxII}^\top \veeMatOp(\bodyDissMatCp{\BidxI}{\BidxII}) \bodyJac{\BidxI}{\BidxII}$}
%  \newcommand{\macInertiaMatAppOne}{$\sysInertiaMatC = \sum_{\BidxI, \BidxII} \bodyJac{\BidxI}{\BidxII}^\top \veeMatOp(\bodyInertiaMatCp{\BidxI}{\BidxII}) \bodyJac{\BidxI}{\BidxII}$}
%  \newcommand{\macTransportMap}{$\differentialR \potentialEnergyC = -\sysTransportMap^\top \differential \potentialEnergyC$}
%  \newcommand{\macVelError}{$\sysVelE = \sysVel - \sysTransportMap \sysVelR$}
% % \newcommand{\macKineticEquationAppOne}{$\sysInertiaMatCoeffC{\LidxI\LidxII} \sysVelCoeffEd{\LidxII} + \ConnCoeffLC{\LidxI}{\LidxII}{\LidxIII} \sysVelCoeff{\LidxIII} \sysVelCoeffE{\LidxII} + \sysDissMatCoeffC{\LidxI\LidxII} \sysVelCoeffE{\LidxII} + \dirDiff{\LidxI} \potentialEnergyC = 0$}
%  \newcommand{\macKineticEquationAppOne}{$\sysInertiaMatC \sysVelEd + \ConnMatC \sysVelE + \sysDissMatC \sysVelE + \differential \potentialEnergyC = \tuple{0}$}
%  \newcommand{\macBodyConfigErrorAppTwo}{$\configErr{\BidxI}{\BidxII} = \bodyHomoCoord{\BidxI}{\BidxII} - \bodyHomoCoordR{\BidxI}{\BidxII}$}
%  \newcommand{\macBodyConfigErrorAppThree}{$\configErr{\BidxI}{\BidxII} = \bodyHomoCoordR{\BidxI}{\BidxII}^{-1} \bodyHomoCoord{\BidxI}{\BidxII} - \idMat[4]$}
%  \newcommand{\macPotentialAppTwo}{$\potentialEnergyC = \sum_{\BidxI, \BidxII} \tfrac{1}{2} \norm[\bodyStiffMatCp{\BidxI}{\BidxII}]{\configErr{\BidxI}{\BidxII}^\top}^2$}
%  \newcommand{\macDissFktAppTwo}{$\dissFktC = \sum_{\BidxI, \BidxII} \tfrac{1}{2} \norm[\bodyDissMatCp{\BidxI}{\BidxII}]{\configErrd{\BidxI}{\BidxII}^\top}^2$}
%  \newcommand{\macAccEnergyAppTwo}{$\accEnergyC = \sum_{\BidxI, \BidxII} \tfrac{1}{2} \norm[\bodyInertiaMatCp{\BidxI}{\BidxII}]{\configErrdd{\BidxI}{\BidxII}^\top}^2$}
%  \newcommand{\macKineticEquationAppTwo}{$\pdiff[\accEnergyC]{\sysVeld} + \pdiff[\dissFktC]{\sysVel} + \differential\potentialEnergyC = \tuple{0}$}
%  \newcommand{\macKineticEquationC}{$\sysInertiaMatC(\sysCoord) \sysVeld + \genForceC(\sysCoord, \sysVel, \sysCoordR, \sysVel, \sysVelR) = \tuple{0}$}
%  %\newcommand{\macCtrlStaticMin}{$\begin{array}{rl}\text{minimize} & \norm[\mat{H}]{\sysInput - \sysInput_0}^2 \\ \text{subject to} &\sysInputConstMat \sysInput \leq \sysInputConstVec \end{array}$}
%  \newcommand{\macCtrlStaticMin}{$\sysInput = \argmin \norm[\mat{H}]{\sysInput - \sysInput_0}^2, \, \text{s.t.}\, \sysInputConstMat \sysInput \leq \sysInputConstVec$}
%  \newcommand{\macCtrlEqI}{$\mat{H} = \sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC \sysInertiaMat^{-1} \sysInputMat$}
%  \newcommand{\macCtrlEqII}{$\sysInput_0 = \mat{H}^{-1} \sysInputMat^\top \sysInertiaMat^{-1} (\sysInertiaMatC \sysInertiaMat^{-1} \genForce - \genForceC)$}
%  \newcommand{\macKonstParam}{$\bodyStiffMatCp{\BidxI}{\BidxII}, \bodyDissMatCp{\BidxI}{\BidxII}, \bodyInertiaMatCp{\BidxI}{\BidxII} \in \SymMatP(4), \, \BidxI, \BidxII = 0,\ldots,\numRigidBodies$}
%  \input{graphics/CtrlApproachSummary.pdf_tex}
%  \caption{Summary of the control design procedure}
%  \label{fig:CtrlApproachSummary}
% \end{figure}

\paragraph*{THE recipe:}
% Let the rigid body system under consideration be parameterized by the (possibly redundant) coordinates $\sysCoord(t)\in\configSpace$.
% This means that we can express all configurations of its individual rigid bodies by $\bodyHomoCoord{\BidxI}{\BidxII} : \configSpace \rightarrow \SpecialEuclideanGroup(3) : \sysCoord \mapsto \bodyHomoCoord{\BidxI}{\BidxII}(\sysCoord)$.
\begin{itemize}
\item Modeling: 
A recipe for the derivation of the equations of motion of a rigid body system was given in \autoref{sec:MechRBSSummary}:
 \begin{itemize}\begin{subequations}
  \item Choose a set of (possibly redundant) configuration coordinates $\sysCoord(t)\in\configSpace = \{ \sysCoord\in\RealNum^\numCoord \, | \, \geoConstraint(\sysCoord) = \tuple{0} \}$ and minimal velocity coordinates $\sysVel(t) \in \RealNum^{\dimConfigSpace}$, $\dimConfigSpace=\dim\configSpace$ that are related by the kinematics matrix $\kinMat(\sysCoord)\in\RealNum^{\numCoord\times\dimConfigSpace}$:
  \begin{align}
   \sysCoordd = \kinMat \sysVel   
  \end{align}
  \item Formulate the rigid body configurations $\bodyHomoCoord{\BidxI}{\BidxII}(\sysCoord) \in \SpecialEuclideanGroup(3), \, \BidxI, \BidxII = 0,\ldots,\numRigidBodies$ in terms of the chosen coordinates.
  This determines the body Jacobians
  \begin{align}
   \bodyJac{\BidxI}{\BidxII} &= \tpdiff{\sysCoordd} \veeOp\big( \bodyHomoCoord{\BidxI}{\BidxII}^{-1} \bodyHomoCoordd{\BidxI}{\BidxII} \big) \kinMat
  \end{align}
  \item Compute the model inertia force $\genForceInertia = \sysInertiaMat \sysVeld + \gyroForce$ from the body inertias $\bodyInertiaMatp{0}{\BidxII}$ (see \autoref{sec:RBSInertia})
  \begin{align}
   \sysInertiaMat \!=\! \sumBodies \bodyJac{0}{\BidxII}^\top \veeMatOp(\bodyInertiaMatp{0}{\BidxII}) \bodyJac{0}{\BidxII},
   \
   \gyroForce \!=\! \sumBodies \bodyJac{0}{\BidxII}^\top \big(\veeMatOp(\bodyInertiaMatp{0}{\BidxII}) \bodyJacd{0}{\BidxII} - \ad{\bodyJac{0}{\BidxII}\sysVel}^\top \veeMatOp(\bodyInertiaMatp{0}{\BidxII})\bodyJac{0}{\BidxII} \big) \sysVel
  \end{align}
  \item The model kinetics are the balance of the inertia force $\genForceInertia$, the force of control inputs $\sysInputMat \sysInput$ and whatever other forces $\genForceImpressed$ may act on the system
  \begin{align}
   \sysInertiaMat \sysVeld + \underbrace{\gyroForce + \genForceImpressed}_{\sysForce} = \sysInputMat \sysInput
  \end{align}
 \end{subequations}\end{itemize}
 \item Closed loop template
 \begin{itemize}\begin{subequations}
  \item The template is computed from the body configurations $\bodyHomoCoord{\BidxI}{\BidxII}$, the body Jacobians $\bodyJac{\BidxI}{\BidxII}$ and the control parameters $\bodyStiffMatCp{\BidxI}{\BidxII}, \bodyDissMatCp{\BidxI}{\BidxII}, \bodyInertiaMatCp{\BidxI}{\BidxII}$:
  \begin{align}
   \sysInertiaMatC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeMatOp(\bodyInertiaMatCp{\BidxI}{\BidxII}) \bodyJac{\BidxI}{\BidxII}
  \\
   \genForceStiffC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeTwoOp \big( (\idMat[4] - \bodyHomoCoordE{\BidxI}{\BidxII}^{-1}) \bodyStiffMatCp{\BidxI}{\BidxII} \big)
  \end{align}
  \item particle-based approach (see \autoref{sec:CtrlApproachParticlesRBS})
  \begin{align}
   \genForceDissC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeTwoOp \big(\big( \wedOp(\bodyJac{\BidxI}{\BidxII}(\sysCoord) \sysVel) - \bodyHomoCoordE{\BidxI}{\BidxII}^{-1} \wedOp(\bodyJac{\BidxI}{\BidxII}(\sysCoordR) \sysVelR) \big) \bodyDissMatCp{\BidxI}{\BidxII} \big)
  \\
   \gyroForceC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeTwoOp \big(\big( \wedOp(\bodyJacd{\BidxI}{\BidxII} \sysVel) + \wedOp(\bodyJac{\BidxI}{\BidxII} \sysVel)^2
   \nonumber\\ &\hspace{4em} -\bodyHomoCoordE{\BidxI}{\BidxII}^{-1} \big( \wedOp(\bodyJacR{\BidxI}{\BidxII}\sysVelRd + \bodyJacRd{\BidxI}{\BidxII} \sysVelR) + \wedOp(\bodyJacR{\BidxI}{\BidxII} \sysVelR)^2 \big) \big) \bodyInertiaMatCp{\BidxI}{\BidxII} \big)
  \end{align}
  \item body-based approach (see \autoref{sec:CtrlApproachBodyRBS})
  \begin{align}
   \genForceDissC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeMatOp(\bodyDissMatCp{\BidxI}{\BidxII})\bodyVelE{\BidxI}{\BidxII}, \qquad \bodyVelE{\BidxI}{\BidxII} = \bodyJac{\BidxI}{\BidxII} \sysVel - \Ad{\bodyHomoCoordE{\BidxI}{\BidxII}^{-1}} \bodyJacR{\BidxI}{\BidxII} \sysVelR, 
  \\
   \gyroForceC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \big( \bodyInertiaMatC{\BidxI}{\BidxII} (\bodyJacd{\BidxI}{\BidxII} \sysVel - \Ad{\bodyHomoCoordE{\BidxI}{\BidxII}^{-1}} (\bodyJacR{\BidxI}{\BidxII} \sysVelRd + \bodyJacRd{\BidxI}{\BidxII} \sysVelR) + \ad{\bodyVelE{\BidxI}{\BidxII}} \Ad{\bodyHomoCoordE{\BidxI}{\BidxII}^{-1}} \bodyJacR{\BidxI}{\BidxII} \sysVelR)
   \nonumber\\ &\hspace{20em} -\ad{\bodyVelE{\BidxI}{\BidxII}}^\top \bodyInertiaMatC{\BidxI}{\BidxII} \bodyVelE{\BidxI}{\BidxII} \big), 
  \end{align}
  \item energy-based approach (see \autoref{sec:CtrlApproachEnergyRBS}, requires the choice of a transport map $\sysTransportMap$)
  \begin{align}
   \genForceDissC &= \sysDissMatC \sysVelE, 
  \quad
   \sysDissMatC = \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \veeMatOp(\bodyDissMatCp{\BidxI}{\BidxII}) \bodyJac{\BidxI}{\BidxII},
  \quad 
   \sysVelE = \sysVel - \sysTransportMap \sysVelR
  \\
   \ConnMatC &= \sumBodiesAB \bodyJac{\BidxI}{\BidxII}^\top \big( \veeMatOp(\bodyInertiaMatCp{\BidxI}{\BidxII}) \bodyJacd{\BidxI}{\BidxII} + \bodyConnMatC{\BidxI}{\BidxII} \bodyJac{\BidxI}{\BidxII} \big), \quad \bodyConnMatCoeffC{\BidxI}{\BidxII}{\LBidxI}{\LBidxII} = \bodyConnFkt{\LBidxI}{\LBidxII}{\LBidxIII}(\bodyInertiaMatCp{\BidxI}{\BidxII}) \bodyJacCoeff{\BidxI}{\BidxII}{\LBidxIII}{\LidxIII} \sysVelCoeff{\LidxIII}
  \\
   \gyroForceC &= \ConnMatC \sysVelE - \sysInertiaMatC(\sysTransportMap\sysVelRd + \sysTransportMapd\sysVelR),
  \end{align}
  \item The desired closed loop kinetics are
  \begin{align}
   \sysInertiaMatC \sysVeld + \underbrace{\gyroForceC + \genForceDissC + \genForceStiffC}_{\sysForceC} = \tuple{0}
  \end{align}
 \end{subequations}\end{itemize}
 \item Control law:
 \begin{itemize}\begin{subequations}
  \item For the fully actuated case, the desired closed loop is realized by  
  \begin{align}
   \sysInput = \sysInputMat^{-1} (\sysForce - \sysInertiaMat \sysInertiaMatC^{-1}\sysForceC)
  \end{align}
  \item In the underactuated case, the acceleration error measured by the Gaussian constraint, is minimized by (see \autoref{sec:CtrlUnderactuatedOptim})
  \begin{align}
   \sysInput &= (\sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC \sysInertiaMat^{-1} \sysInputMat)^{-1} \sysInputMat^\top \sysInertiaMat^{-1} (\sysInertiaMatC \sysInertiaMat^{-1} \sysForce - \sysForceC)
  \end{align}
  Choosing an orthogonal complement $\sysInputMatLComp$ to the input matrix $\sysInputMat$, i.e.\ $\rank \sysInputMatLComp = \dimConfigSpace-\numInputs$ and $\sysInputMat^\top \sysInputMatLComp = \mat{0}$, the residual acceleration error can be written as $\GaussianConstraintC_0 = \tfrac{1}{2} \norm[\mat{S}]{\tuple{\lambda}}^2$ where (see \autoref{sec:MatchingCondition})
  \begin{align}
   \tuple{\lambda} = (\sysInputMatLComp)^\top (\sysInertiaMat \sysInertiaMatC^{-1} \sysForceC - \sysForce) = \tuple{0},
   \qquad
   \mat{S} = \big( (\sysInputMatLComp)^\top \sysInertiaMat \sysInertiaMatC^{-1} \sysInertiaMat \sysInputMatLComp \big)^{-1}
  \end{align}
  By adjusting the control parameters within $\sysInertiaMatC$ and $\sysForceC$ one may try to minimize $\GaussianConstraintC_0$.
 \end{subequations}\end{itemize}
\end{itemize}


