\section{Underactuated systems}\label{sec:CtrlUnderactuated}
The first three sections of this chapter motivated different desired closed loop dynamics which share the structure
\begin{align}\label{eq:CtrlClosedLoopUnderactuated}
 \sysCoordd = \kinMat(\sysCoord) \sysVel, 
\quad
 \sysInertiaMatC(\sysCoord) \sysVeld + \sysForceC(\sysCoord, \sysVel, \sysCoordR, \sysVelR, \sysVelRd) = \tuple{0}.
\end{align}
The system model with the available control input $\sysInput$ has the form of \eqref{eq:CtrlSysMdl}:
\begin{align}\label{eq:CtrlSysMdlUnderactuated}
 \sysCoordd = \kinMat(\sysCoord) \sysVel, 
\quad
 \sysInertiaMat(\sysCoord) \sysVeld + \sysForce(\sysCoord, \sysVel) = \sysInputMat(\sysCoord) \sysInput.
\end{align}
For a fully actuated system, i.e.\ $\rank\sysInputMat = \dimConfigSpace$, the combination of \eqref{eq:CtrlClosedLoopUnderactuated} and \eqref{eq:CtrlSysMdlUnderactuated} can be solved for the system input $\sysInput$ yielding the required control law:
\begin{align}
 \sysInput = \sysInputMat^{-1}\big( \sysForce - \sysInertiaMat \sysInertiaMatC^{-1} \sysForceC \big)
 .
\end{align}

For an underactuated system, i.e.\ $\rank\sysInputMat = \numInputs < \dimConfigSpace$, this is generally not possible.


\subsection{Control law through static optimization}\label{sec:CtrlUnderactuatedOptim}

\paragraph{The idea.}
If the desired closed loop dynamics \eqref{eq:CtrlClosedLoopUnderactuated} cannot be achieved exactly, the next best thing is to get ``as close as possible'' while still obeying the model dynamics \eqref{eq:CtrlSysMdlUnderactuated}.
In order to formalize the ``as close as possible'' we take again inspiration from mechanics, more precicely from Gauss' principle of least constraint, previously discussed in \autoref{sec:MechConstrainedParticles}:
The free motion is the solution of the desired closed loop \eqref{eq:CtrlClosedLoopUnderactuated}, the optimization metric is the desired closed loop inertia $\sysInertiaMatC$ and the constraints are the model kinetics \eqref{eq:CtrlSysMdlUnderactuated}.
Then the control law is the solution of the static optimization problem
\begin{align}\label{eq:MinProbUnderactuated}
 \begin{array}{rl}
  \text{minimize} & \GaussianConstraintC \, = \, \tfrac{1}{2} \norm[\sysInertiaMatC]{\sysVeld + \sysInertiaMatC^{-1} \sysForceC}^2
  \\[1ex]
  \text{subject to} & \sysInertiaMat \sysVeld + \sysForce = \sysInputMat \sysInput, \ \sysInput \in \RealNum^\numInputs 
 \end{array}
 .
\end{align}
%Mathematically we do not have to use the metric coefficients $\sysInertiaMatC$ here for the optimization, any other symmetric positive definite matrix would serve the purpose as well.
%However, from the physics point of view, the terms in the norm correspond to an acceleration, so the inertia of the desired closed loop is the reasonable choice.
%Furthermore, from the control point of view, the additional parameters arising with a different matrix would not turn out to be really useful.

\paragraph{Explicit control law.}
Elimination of the acceleration $\sysVeld = \sysInertiaMat^{-1}(\sysInputMat \sysInput - \sysForce)$ from \eqref{eq:MinProbUnderactuated} leads to
\begin{align}\label{eq:GaussianUnderactuated}
 \GaussianConstraintC &= \tfrac{1}{2} \norm[\sysInertiaMatC]{\sysInertiaMat^{-1}\sysInputMat \sysInput - \underbrace{(\sysInertiaMat^{-1}\sysForce - \sysInertiaMatC^{-1}\sysForceC)}_{\tilde{\tuple{a}}}}^2
\nonumber\\
 &= \tfrac{1}{2} \sysInput^\top \underbrace{\sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC \sysInertiaMat^{-1} \sysInputMat}_{\mat{H}} \sysInput - \sysInput^\top \sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC \tilde{\tuple{a}} + \tfrac{1}{2} \tilde{\tuple{a}}^\top \sysInertiaMatC \tilde{\tuple{a}}
\nonumber\\
 &= \tfrac{1}{2} \big( \sysInput - \underbrace{\mat{H}^{-1} \sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC \tilde{\tuple{a}}}_{\sysInput_0} \big)^\top \mat{H} \big(\sysInput - \underbrace{\mat{H}^{-1} \sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC \tilde{\tuple{a}}}_{\sysInput_0} \big)
\nonumber\\
 &\hspace{10em}+ \tfrac{1}{2} \tilde{\tuple{a}}^\top \sysInertiaMatC \underbrace{\big( \idMat[\dimConfigSpace] - \sysInertiaMat^{-1} \sysInputMat \mat{H}^{-1} \sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC \big)}_{\mat{P}^\bot} \tilde{\tuple{a}}
\nonumber\\
 &= \tfrac{1}{2} \norm[\mat{H}]{\sysInput - \sysInput_0}^2 + \underbrace{\tfrac{1}{2} \norm[\sysInertiaMatC]{\mat{P}^\bot \tilde{\tuple{a}}}^2}_{\GaussianConstraintC_0}.
\end{align}
The control law, i.e.\ the solution of the minimization problem, is obviously $\sysInput = \sysInput_0$.
%For the formulation of $\GaussianConstraintC_0$ it is crucial to note that $\mat{P}^\bot$ is a projection matrix, which will be exploited in the next subsection.

For the special case of a fully actuated system, i.e.\ $\sysInputMat$ is invertible, the control law simplifies to $\sysInput_0 = \sysInputMat^{-1} (\sysForce - \sysInertiaMat \sysInertiaMatC^{-1}\sysForceC)$ as already stated above.
Furthermore, for this case, we have $\mat{P}^\bot = \mat{0}$ and consequently $\GaussianConstraintC_0=0$.

\paragraph{Feasible closed loop kinetics.}
Plugging $\sysInput = \sysInput_0$ into the model \eqref{eq:CtrlSysMdlUnderactuated} we obtain the actual closed loop kinetics:
\begin{align}\label{eq:UnderactuatedControlledKinetics}
 \sysInertiaMat \sysVeld + \sysForce &= \sysInputMat \overbrace{\mat{H}^{-1} \sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC (\sysInertiaMat^{-1}\sysForce - \sysInertiaMatC^{-1}\sysForceC)}^{\sysInput_0}
\nonumber\\
\Leftrightarrow \qquad \qquad 
 \sysVeld &= \sysInertiaMat^{-1} \sysInputMat \mat{H}^{-1} \sysInputMat^\top \sysInertiaMat^{-1} \sysInertiaMatC (\sysInertiaMat^{-1}\sysForce - \sysInertiaMatC^{-1}\sysForceC) - \sysInertiaMat^{-1} \sysForce
% \sysVeld &= \underbrace{\sysInputMatAst \mat{H}^{-1} \sysInputMatAst^\top \sysInertiaMatC}_{\idMat[\dimConfigSpace] - \mat{P}^\bot} (\sysInertiaMat^{-1}\sysForce - \sysInertiaMatC^{-1}\sysForceC) - \sysInertiaMat^{-1} \sysForce
\nonumber\\
\qquad \Leftrightarrow \qquad
 \sysInertiaMatC \sysVeld + \sysForceC &= \underbrace{\sysInertiaMatC \mat{P}^\bot \big( \sysInertiaMatC^{-1} \sysForceC - \sysInertiaMat^{-1} \sysForce \big)}_{\tilde{\sysForce}}.
\end{align}
We may interpret this additional vector\footnote{The coefficients $\tilde{\tuple{b}}$ do indeed transform like a tensor, even though $\sysForce$ and $\sysForceC$ do not.}
$\tilde{\tuple{b}}(\sysCoord, \sysVel, \sysCoordR, \sysVelR, \sysVelRd) \in \RealNum^{\dimConfigSpace}$ as a force that makes the closed loop kinetics feasible, i.e.\ realizable with the available controls.
The residual Gaussian constraint is $\GaussianConstraintC_0 = \tfrac{1}{2} \norm[\sysInertiaMatC^{-1}]{\tilde{\sysForce}}^2$.

In general, the value $\GaussianConstraintC_0$ is a measure of how much the resulting closed loop differs from the original desired system \eqref{eq:CtrlClosedLoopUnderactuated}.
One main goal when parameterizing the controller is to make $\GaussianConstraintC_0$ as small as possible.
Unfortunately the form of $\GaussianConstraintC_0$ in \eqref{eq:UnderactuatedControlledKinetics} is not handy, mainly due to $\rank \mat{P}^\bot = \dimConfigSpace - \numInputs$.
In the following we like to find a more handy formulation.

\subsection{Matching condition}\label{sec:MatchingCondition}
Instead of elimiating the accelerations $\sysVeld$ we may also eliminate the controls $\sysInput$ from \eqref{eq:MinProbUnderactuated}.
Let $\sysInputMatLComp \in \RealNum^{\dimConfigSpace\times(\dimConfigSpace-\numInputs)}$ be any orthogonal complement to $\sysInputMat$, i.e.\ $\rank \sysInputMatLComp = \dimConfigSpace-\numInputs$ and $\sysInputMat^\top \sysInputMatLComp = \mat{0}$.
With this \eqref{eq:MinProbUnderactuated} is equivalent to
\begin{align}\label{eq:MinProbUnderactuatedMatch}
 \begin{array}{rl}
  \text{minimize} & \GaussianConstraintC \, = \, \tfrac{1}{2} \norm[\sysInertiaMatC]{\sysVeld + \sysInertiaMatC^{-1} \sysForceC}^2
  \\[1ex]
  \text{subject to} & (\sysInputMatLComp)^\top \big(\sysInertiaMat \sysVeld + \sysForce\big) = \tuple{0}
 \end{array}
 .
\end{align}
Using the method of Lagrangian multipliers with $\Lagrangian = \GaussianConstraintC + \tuple{\mu}^\top (\sysInputMatLComp)^\top \big(\sysInertiaMat \sysVeld + \sysForce\big)$ 
leads to the neccessary condition
\begin{align}
  \begin{bmatrix} \pdiff[\Lagrangian]{\sysVeld} \\ \pdiff[\Lagrangian]{\tuple{\mu}} \end{bmatrix}
  =
  \begin{bmatrix} \sysInertiaMatC & \sysInertiaMat \sysInputMatLComp \\ (\sysInertiaMat \sysInputMatLComp)^\top & \mat{0} \end{bmatrix}
  \begin{bmatrix} \sysVel \\ \tuple{\mu} \end{bmatrix}
  +
  \begin{bmatrix} \sysForceC \\ (\sysInputMatLComp)^\top\sysForce \end{bmatrix}
  = \tuple{0}
 %\sysInertiaMatC (\sysVeld + \sysInertiaMatC^{-1} \sysForceC) - \sysInertiaMat \sysInputMatLComp \tuple{\lambda}
\end{align}
Using blockwise inversion we may solve
\begin{align}\label{eq:DefMatchingForce}
 -\tuple{\mu} = \underbrace{\big( (\sysInertiaMat \sysInputMatLComp)^\top \sysInertiaMatC^{-1} \sysInertiaMat \sysInputMatLComp \big)^{-1}}_{\mat{S}} \underbrace{(\sysInputMatLComp)^\top (\sysInertiaMat \sysInertiaMatC^{-1} \sysForceC - \sysForce)}_{\tuple{\lambda}}.
%\qquad
% \mat{S} = \big( (\sysInertiaMat \sysInputMatLComp)^\top \sysInertiaMatC^{-1} \sysInertiaMat \sysInputMatLComp \big)^{-1}
\end{align}
With this, the feasible closed loop kinetics and the residual Gaussian constraint may be expressed by
\begin{align}
 \sysInertiaMatC\sysVeld + \sysForceC = \underbrace{\sysInertiaMat \sysInputMatLComp \mat{S} \, \tuple{\lambda}}_{\tilde{\sysForce}} \ ,
\qquad
 \GaussianConstraintC_0 = \tfrac{1}{2} \norm[\mat{S}]{\tuple{\lambda}}^2.
\end{align}
It is much simpler to analyse $\tuple{\lambda}$ which has only the dimension of the underactuation $\dimConfigSpace-\numInputs$ instead of $\tilde{\tuple{b}}$ which has the full dimension $\dimConfigSpace$ of the configuration space.
% The value of $\GaussianConstraintC_0$ is a measure of how much the actual closed loop \eqref{eq:UnderactuatedControlledKinetics} differs from the original desired closed loop \eqref{eq:CtrlClosedLoopUnderactuated}.
% With the use of a basis, the columns of $\sysInputMatLComp$, we are able to formulate this measure in terms of minimal coefficients $\tuple{\lambda}$.
% This will turn out very useful for the actual design.
Though it should be stressed that the values of $\GaussianConstraintC_0$ and $\tilde{\tuple{b}}$ are, as derived above, independent of the choice of $\sysInputMatLComp$.

The best case is, of course, if we achieve 
\begin{align}\label{eq:MatchingCondition}
 \tuple{\lambda} = (\sysInputMatLComp)^\top (\sysInertiaMat \sysInertiaMatC^{-1} \sysForceC - \sysForce) = \tuple{0}
\qquad \Rightarrow \qquad
 \tilde{\tuple{b}} = \tuple{0}, \ \GaussianConstraintC_0 = 0
\end{align}
i.e.\ the desired closed loop is realized exactly.
An approach based on this is discussed in \cite{bloch2000controlled}.
A condition similar to \eqref{eq:MatchingCondition} is therein called the \textit{the matching condition} and is required to be fulfilled exactly.
However, the examples for which this approach is demonstrated restricts to stabilization tasks $\sysVelR = \tuple{0}$ for small academic systems.

An advantage of the presented approach is that the control law $\sysInput = \sysInput_0$ is defined independently of whether the matching condition is fulfilled or not.
Instead the quantity $\tuple{\lambda}$, which we will call the \textit{matching force} in the following, ensures that the control law is realizable.

\subsection{Approximations}
The matching force \eqref{eq:MatchingCondition} may become very cumbersome for complex systems and might even be impossible to vanish with the given parameters.
It might be instructive to analyse it for particular situations.

\paragraph{Zero error.}
Assume that the controller tracks the reference perfectly, i.e.\ $\sysCoord = \sysCoordR$ and $\sysVel=\sysVelR$.
One may check that for this case the three approaches all yield $\sysForceC = \sysInertiaMatC\sysVelRd$.
The resulting matching force $\tuple{\lambda}^{\text{ZeroError}}$ for this special case is
\begin{align}\label{eq:MatchingForceZeroError}
 \tuple{\lambda}^{\text{ZeroError}} = (\sysInputMatLComp(\sysCoordR))^\top (\sysInertiaMat(\sysCoordR) \sysVelRd - \sysForce(\sysCoordR, \sysVelR))
\end{align}
Evidently, this is independent of the closed loop parameters, and should rather be regarded as a constraint on the \textit{reference trajectory} $t\mapsto \sysCoordR(t)$.
The condition $\tuple{\lambda}^{\text{ZeroError}}=\tuple{0}$ is essentially the model equation after elimination of the control inputs.

A very useful approach here is to formulate the reference trajectory in terms of a \textit{flat output} \cite{Fliess:Flatness} of the model.
The first step for a systematic construction of a flat output is commonly the elimination of the control inputs (see e.g.\ \cite{Schlacher:ConstructionOfFlatOutputs}) i.e.\ $\tuple{\lambda}^{\text{ZeroError}}=\tuple{0}$.

\paragraph{Small error.}
Assume that we a small error $\LinErrorCoord = \kinMat^+(\sysCoordR)(\sysCoord-\sysCoordR)$ to a constant reference $\sysVelR=\tuple{0}$ as already considered in \autoref{sec:CtrlLinearization}.
Then the model and the closed loop template may be approximated by
\begin{subequations}
\begin{align}
 \sysInertiaMatLin \LinErrorCoorddd + \sysDissMatLin \LinErrorCoordd + \sysStiffMatLin \LinErrorCoord &= \sysInputMat(\sysCoordR) \Delta \tuple{u},
\\
 \sysInertiaMatCLin \LinErrorCoorddd + \sysDissMatCLin \LinErrorCoordd + \sysStiffMatCLin \LinErrorCoord &= \tuple{0}
\end{align}
\end{subequations}
and the matching force $\tuple{\lambda}^{\text{SmallError}}$ for this special case is
\begin{align}\label{eq:MatchingForceLin}
 \tuple{\lambda}^{\text{SmallError}} &= (\sysInputMatLComp(\sysCoordR))^\top \big( \sysInertiaMatLin \sysInertiaMatCLin^{-1} (\sysDissMatCLin \LinErrorCoordd + \sysStiffMatCLin \LinErrorCoord) - (\sysDissMatLin \LinErrorCoordd + \sysStiffMatLin \LinErrorCoord) \big)
\nonumber\\
 &= \underbrace{(\sysInputMatLComp(\sysCoordR))^\top \big( \sysInertiaMatLin \sysInertiaMatCLin^{-1} \sysDissMatCLin - \sysDissMatLin\big)}_{\mat{\Lambda}_{\sysDissMat}} \LinErrorCoordd
  + \underbrace{(\sysInputMatLComp(\sysCoordR))^\top \big( \sysInertiaMatLin \sysInertiaMatCLin^{-1} \sysStiffMatCLin - \sysStiffMatLin\big)}_{\mat{\Lambda}_{\sysStiffMat}} \LinErrorCoord
\end{align}
As $\LinErrorCoord$ and $\LinErrorCoordd$ can be arbitrary, the matrices $\mat{\Lambda}_{\sysStiffMat}$ and $\mat{\Lambda}_{\sysDissMat}$ have to vanish, for $\tuple{\lambda}^{\text{SmallError}}$ to vanish.
For the following examples it will turn out that we can always find suitable parameters within $\sysInertiaMatCLin$, $\sysDissMatCLin$ and $\sysStiffMatCLin$ such that $\mat{\Lambda}_{\sysStiffMat} = \mat{\Lambda}_{\sysDissMat} = \mat{0}$.
Thus ensuring that at least the first order approximation of the actual matching force $\tuple{\lambda}$ vanishes.


\subsection{Systems with input constraints}
In most control systems the control inputs $\sysInput$ can not take arbitrary values, but due to practical limitations are required to be e.g. $\sysInputCoeff{a} \in [-\sysInputCoeff{a}^{\idxMax}, \sysInputCoeff{a}^{\idxMax}], a=1,\ldots,\numInputs$.
More generally we assume that the constraints can be written as $\sysInputConstMat \sysInput \leq \sysInputConstVec$ where the inequality is understood componentwise.
Adding this constraint to the original problem \eqref{eq:MinProbUnderactuated} is
\begin{align}\label{eq:MinProbUnderactuatedInputConst}
 \begin{array}{rl}
  \text{minimize} & \GaussianConstraintC \, = \, \tfrac{1}{2} \norm[\sysInertiaMatC]{\sysVeld + \sysInertiaMatC^{-1} \sysForceC}^2
  \\[1ex]
  \text{subject to} & \sysInertiaMat \sysVeld + \sysForce = \sysInputMat \sysInput, \ \sysInputConstMat \sysInput \leq \sysInputConstVec, \ \sysInput \in \RealNum^\numInputs 
 \end{array}
 .
\end{align}
With the elimination of $\sysVeld$ as done in \autoref{sec:CtrlUnderactuatedOptim} this is equivalent to
\begin{align}\label{eq:MinProbInputConstraints}
 \begin{array}{rl}
  \text{minimize} & \GaussianConstraintC \, = \, \tfrac{1}{2} \norm[\mat{H}]{\sysInput - \sysInput_0}^2 %+ \GaussianConstraintC_0
  \\[1ex]
  \text{subject to} &\sysInputConstMat \sysInput \leq \sysInputConstVec, \ \sysInput \in \RealNum^\numInputs 
 \end{array}
\end{align}
with $\mat{H}$ and $\sysInput_0$ defined in \eqref{eq:GaussianUnderactuated}.

Given that $\mat{H} \in \SymMatP(\numInputs)$ by construction and the feasible set $\mathbb{U} = \{ \sysInput \in \RealNum^\numInputs \, | \, \sysInputConstMat \sysInput \leq \sysInputConstVec \}$ is convex, this problem has a unique solution, though it usually has to be computed numerically.
For the following simulation results the \textsc{Matlab} function \texttt{quadprog} was used and a C++ implementation of the Active-Set algorithm from \cite[Algorithm 16.3]{Nocedal:NumericalOptimization} was used for the real-time implementation on the Multicopters.

If $\sysInput_0 \in \mathbb{U}$ the solution is obviously $\sysInput = \sysInput_0$ and is independent of $\mat{H}$.
If this is not the case the matrix $\mat{H}$ determines which components of $\sysInput$ are prioritized.
It is crucial to notice that $\mat{H}$ is not the tuning parameter here, but is computed from the desired system inertia $\sysInertiaMatC$ and the model matrices, see \eqref{eq:GaussianUnderactuated}.
As evident from \eqref{eq:MinProbUnderactuatedInputConst}, the actual tuning parameter here is the desired closed loop inertia matrix $\sysInertiaMatC$ which determines how the components of the system acceleration $\sysVeld$ are prioritized when computing a feasible control force.
