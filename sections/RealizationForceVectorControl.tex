\section{Control of the generalized force}\label{sec:RealizationForceVectorControl}
The rigid body controller computes a \textit{desired} generalised force $\genForceD$ for the corresponding multicopter.
This force cannot be realized instantaneously as its subject to its own actuator dynamics, see \autoref{sec:RealizationModels}.
This section describes a control approach for the generalized force $\genForce$

Since the force $\genForce$ itself is subject , it is not possible to realize it instantaneously.
However, we can pursue to realise it reasonably fast, which is the subject of this section.
At the same time we need an accurate estimate for the current generalized force for the rigid body observer.
The coarse structure was alredy given in \autoref{fig:StructureMulticopterAgent}.

\subsection{Servo simulation}
The integrated servo controller uses an internal angle measurement but this is not available for the main controller.
A dedicated test bench (see \autoref{fig:PropellerTestBench}) with an absolute encoder for the tilt angle $\aServo$ was used for validation of the servo dynamics \eqref{eq:TriModelServoDynamics} and identification of its parameters $\ServoParam[0]$ and $\ServoParam[1] $.
Since the model is asymptotically stable, a simple online simulation of the model with the known servo setpoint $\aServoU[][k]$ is sufficient to get an estimate of the current servo angle.
For this a simple forward Euler discretization of \eqref{eq:TriModelServoDynamics} is implemented on the main controller
\begin{subequations}\label{eq:ServoSimulator}
\begin{align}
 \aServoObs[][k\!+\!1] &= \aServoObs[][k] + \Ts \aServoObsd[][k]
\\
 \aServoObsd[][k\!+\!1] &= \aServoObsd[][k] + \Ts( \ServoParam[0] (\aServoU[][k] - \aServoObs[][k]) - \ServoParam[1] \aServoObsd[][k])
 .
\end{align}
\end{subequations}
% \fixme{Servo param}
% \begin{align}
%  p_{\textsf{S}0} = \tfrac{K_P}{\ArmInertia}, \
%  p_{\textsf{S}1} = \tfrac{K_D}{\ArmInertia}
% \end{align}
In \autoref{fig:ServoSimRes} its result is compared to the measurement of the encoder.
To be close to the real application on the Tricopter, the propeller on the test bench is spinning with about $70\,\unit{Hz}$ during the experiment.
This explains the vibration seen in the encoder measurements.
If the propeller is switched off, the estimation error is always less than $\pm 0.5\,\unit{DEG}$.

\begin{figure}
 \centering
 \footnotesize
 \appendtographicspath{{graphics/ServoSimRes/}}
 \input{graphics/ServoSimRes/ServoSimRes}
 \caption{Servo simulation validation}
 \label{fig:ServoSimRes}
\end{figure}

\subsection{Propeller tracking control}
The forward Euler discretization of the propeller model \eqref{eq:QuadPropDynamics} is
\begin{align}\label{eq:PropDynamics}
 \PropVel[][k\!+\!1] = \PropVel[][k] + \Ts \big( \PropParam[2] \BLDCCurr[][k] - \PropParam[3] - \PropParam[1] \big( \PropVel[][k]\big)^2 \big),
\end{align}

\paragraph*{Measurement model.}
From the commutation algorithm of the BLDC driver we get an estimate $\PropVelMeas$ of the propeller velocity which relies on its \textit{angle} $\PropAngle$ estimation used for the commutation, which is
\begin{align}
 \PropVelMeas[][k] = \tfrac{1}{\Ts} \big( \PropAngle[][k] - \PropAngle[][k\!-\!1] \big)
 .
\end{align} 
Assuming that the angular acceleration $\PropVeld$ is roughly constant within one sampling step, we have the relations
\begin{align}
 \PropAngle[][k] = \PropAngle[][k\!-\!1] + \PropVel[][k\!-\!1] \Ts + \tfrac{1}{2} \PropVeld[][k\!-\!1] \Ts^2,
\quad
 \PropVeld[][k\!-\!1] = \tfrac{1}{\Ts} \big( \PropVel[][k] - \PropVel[][k\!-\!1] \big)
 .
\end{align}
So the estimate corresponds to the mean velocity between the current and the last sampling step, \ie
\begin{align}\label{eq:PropMeaseq}
 \PropVelMeas[][k] = \tfrac{1}{2} \big( \PropVel[][k] + \PropVel[][k\!-\!1] \big)
 .
\end{align} 

\paragraph*{Observer.}
The velocity estimate $\PropVelMeas$ from the BLDC driver is quite noisy, so it should not be used directly in a feedback.
The scaled model \eqref{eq:PropDynamics} also contains the a friction parameter $\PropParam[3] = \tfrac{\BLDCFriction}{\PropInertia}$ which we like to estimate online for each propeller drive individually.
To address these two aspects, an observer for each propeller drive is implemented on the main controller.
It is essentially a copy of the discrete model \eqref{eq:PropDynamics} supplemented with a linear error feedback
\begin{subequations}\label{eq:PropObserver}
\begin{align}
 e[k] &= \PropVelMeas[][k] - \tfrac{1}{2} \big( \PropVelObs[][k] + \PropVelObs[][k-1] \big)
\\
 \PropVelObs[][k+1] &= \PropVelObs[][k] + \Ts \big( \PropParam[2] \BLDCCurr[][k] - \PropParamObs[3][k] - \PropParam[1] \big( \PropVelObs[][k]\big)^2 + \PropObsGainVel e[k] \big),
\\
 \PropParamObs[3][k+1] &= \PropParamObs[3][k] + \Ts \PropObsGainBias e[k].
\end{align}
\end{subequations}
where $\PropObsGainVel, \PropObsGainBias \in \RealNum$ are the feedback gains.
For quantitative analysis of the observer we consider the linearization of the observer error dynamics about a general expansion point $\PropVel = \PropVelStat > 0$.
Its characteristic polynomial is
\begin{align}
 \lambda^3 
 + \big( \tfrac{\Ts}{2} \big( 4 \PropParam[1] \PropVelStat + \PropObsGainVel \big) - 2 \big) \lambda^2
 + \big( 1 - \tfrac{\Ts}{2} \big( 4 \PropParam[1] \PropVelStat + \Ts \PropObsGainBias \big) \big) \lambda
 - \tfrac{\Ts}{2} \big( \PropObsGainVel + \Ts \PropObsGainBias \big)
 = 0
\end{align}
The roots $\lambda$ for the given parameters are shown in \fixme{(fixme)}.

% \begin{subequations}
% \begin{align}
%  a_0 &= -\tfrac{\Ts}{2} \big( \PropObsGainVel + \Ts \PropObsGainBias \big),
% \\
%  a_1 &= 1 - \tfrac{\Ts}{2} \big( 4 \PropParam[1] \PropVelStat + \Ts \PropObsGainBias \big),
% \\
%  a_2 &= \tfrac{\Ts}{2} \big( 4 \PropParam[1] \PropVelStat + \PropObsGainVel \big) - 2,
% \\
%  a_3 &= 1.
% \end{align}
% \end{subequations}

\paragraph*{Tracking controller.}
Assume that we have a given trajectory $k \mapsto \PropVelDF[][k]$ and we want the trajectory of the propeller velocity $k \mapsto \PropVel[][k]$ (actually its estimate $\PropVelObs$) to converge to it.
Being at the sampling step $k$ the available control input is the motor current $\BLDCCurr[][k\!+\!1]$ for the \textit{next} step.
From the observer \eqref{eq:PropObserver} we have estimates for the velocity $\PropVelObs[][k\!+\!1]$ and the friction $\PropParamObs[3][k\!+\!1]$ at the next sampling step.
Taking this into account we propose the control law:
\begin{subequations}\label{PropCtrlLaw}
\begin{align}
 e[k\!+\!1] &= \PropVelDF[][k\!+\!1] - \PropVelObs[][k\!+\!1],
\\
 \BLDCCurr[][k\!+\!1] &= \tfrac{1}{\PropParam[2]} \big( \tfrac{\PropVelDF[][k+2] - \PropVelDF[][k+1]}{\Ts} + \PropParam[1] \big( \PropVelDF[][k\!+\!1] \big)^2 + \PropParamObs[3][k\!+\!1] + \PropCtrlGain e[k\!+\!1] \big),
\end{align}
\end{subequations}
It is essentially a (shifted) copy of the discrete model \eqref{eq:PropDynamics} supplemented with a linear error feedback with the gain $\PropCtrlGain \in \RealNum$.
Plugging the control law \eqref{PropCtrlLaw} into the model \eqref{eq:PropDynamics} and assuming the observer has converged, \ie $\PropVelObs[][k] = \PropVel[][k]$ and $\PropParamObs[3][k] = \PropParam[3]$, yields the tracking error dynamics
\begin{align}
 e[k\!+\!1] + \big( \Ts (2 \PropParam[1] \PropVel[][k] + \PropCtrlGain) - 1 \big) e[k] + \Ts \PropParam[1] \big( e[k] \big)^2 = 0.
\end{align}
For a the linearization about the expansion point $e = 0$, $\PropVel = \PropVelStat$ the corresponding characteristic polynomial has the root
\begin{align}
 \lambda = 1 - \Ts (2 \PropParam[1] \PropVelStat + \PropCtrlGain).
\end{align}


\begin{figure}
 \centering
 \footnotesize
 \appendtographicspath{{graphics/PropCtrlRes/}}
 \input{graphics/PropCtrlRes/PropCtrlRes}
 \caption{Propeller control validation}
 \label{fig:PropCtrlRes}
\end{figure}

\subsection{Tricopter force control}
The generalized force $\genForce$ on the \Tricopter is a static transformation of the propeller velocities $\PropVel[1], \ldots \PropVel[3]$ and the servo angles $\aServo[1],\ldots,\aServo[3]$ as given in \eqref{eq:TriActuatorTrafo}.
For a given desired generalized force $\genForceD$ we can (partially) invert this relation to obtain the corresponding propeller thrusts $\PropForceD[1], \ldots \PropForceD[3]$ and servo angles $\aServoD[1],\ldots,\aServoD[3]$ as
\begin{align}\label{eq:TriInvActuatorTrafo}
 \F_{\idxDes}^\mathsf{VH} = B^{-1} \genForceD,
\quad
 \PropForceD[j] = \sqrt{(\F_{\idxDes j}^\mathsf{V})^2 + (\F_{\idxDes j}^\mathsf{H})^2},
\quad
 \aServoD[j] = \atanTwo(\F_{\idxDes j}^\mathsf{H}, \F_{\idxDes j}^\mathsf{V}),
\quad j = 1,2,3.
\end{align}
In addition the computed values are saturated to $0.3\,\unit{N} \leq \PropForceD[i] \leq 7.0\,\unit{N}$ and $-45^\circ\leq \aServoD[i] \leq 45^\circ, i=1,2,3$ to incorporate the practical limitations of the actuators.
The desired servo angles $\aServoD[i]$ are directly forwarded to the servo controllers.
In contrast, for the desired thrusts $\PropForce[i]$ a first order filter is applied:
\begin{align}\label{eq:PropPrefilter}
 \PropForceDF[][k\!+\!2] = c_F \PropForceDF[][k\!+\!1] + (1-c_F) \PropForceD[][k\!+\!1],
\qquad
 \PropVelDF[][k\!+\!2] = \sqrt{\sfrac{\PropForceDF[][k\!+\!2]}{\kappaF}}.
\end{align}
This yields the desired propeller velocities $\PropVelDF[i][k+1]$ and $\PropVelDF[i][k+2]$ for the next \textit{two} sampling steps which are required for the propeller \textit{tracking} controller.
After the propeller controller has converged, \ie $\PropForce[i] = \PropForceDF[i]$, the thrust dynamic is completely determined by this filter.

Overall we can combine the discrete servo dynamics \eqref{eq:ServoSimulator}, the thrust filter \eqref{eq:PropPrefilter} and the static transformations \eqref{eq:TriActuatorTrafo} and \eqref{eq:TriInvActuatorTrafo} to obtain a nonlinear dynamic system with the input $\genForceD$ and the output $\genForce$, the \textit{\Tricopter actuator dynamics}.
For a quantitative analysis its first order approximation about a general expansion point $(\PropForceStat[1], \PropForceStat[2], \PropForceStat[3], \aServoStat[1], \aServoStat[2], \aServoStat[3])$ is considered.
Using the $z$-transformation $\ZTrafo{\cdot}$ the linearized dynamics between $\genForce$ and $\genForceD$ can be written as 
\begin{align}
 \ZTrafo{\Delta \genForce} = \GenForceTransferFunction(z) \, \ZTrafo{\Delta \genForceD}.
\end{align}
The discrete transfer function
\begin{align}\label{eq:TriActuatorTransferFunction}
 \GenForceTransferFunction(z) = J \diag(\ThrustTransferFunction(z), \ThrustTransferFunction(z), \ThrustTransferFunction(z), \ServoTransferFunction(z), \ServoTransferFunction(z), \ServoTransferFunction(z)) J^{-1}
\end{align}
consists of $\ThrustTransferFunction(z)$, the transfer function of the thrust filter \eqref{eq:PropPrefilter}, $\ServoTransferFunction(z)$, the transfer function of the controlled servo \eqref{eq:ServoSimulator}:
\begin{align}
 \ThrustTransferFunction(z) = \frac{1-c_F}{z-c_F},
\qquad
 \ServoTransferFunction(z) = \frac{\ServoParam[0] \Ts^2}{(z-1)^2 + \ServoParam[1]\Ts (z-1) + \ServoParam[0] \Ts^2}
 .
\end{align}
and $J$ is the Jacobian matrix of the force transformation \eqref{eq:TriActuatorTrafo} at the expansion point.
\begin{align}
 %\underbrace{\begin{bmatrix} \Delta \Fx \\ \Delta \Fy \\ \Delta \Fz \\ \Delta \taux \\ \Delta \tauy \\ \Delta \tauz \end{bmatrix}}_{\Delta \genForce}
 J = B
 \begin{bmatrix}
  \cos\aServoStat[1] & 0 & 0 & -\PropForceStat[1] \sin\aServoStat[1] & 0 & 0 \\
  0 & \cos\aServoStat[2] & 0 & 0 & -\PropForceStat[2] \sin\aServoStat[2] & 0 \\
  0 & 0 & \cos\aServoStat[3] & 0 & 0 & -\PropForceStat[3] \sin\aServoStat[3] \\
  \sin\aServoStat[1] & 0 & 0 & \PropForceStat[1] \cos\aServoStat[1] & 0 & 0 \\
  0 & \sin\aServoStat[2] & 0 & 0 & \PropForceStat[2] \cos\aServoStat[2] & 0 \\
  0 & 0 & \sin\aServoStat[3] & 0 & 0 & \PropForceStat[3] \cos\aServoStat[3] \\
 \end{bmatrix}
% \begin{bmatrix} \Delta \PropForce[1] \\ \Delta \PropForce[2] \\ \Delta \PropForce[3] \\ \Delta \aServo[1] \\ \Delta \aServo[2] \\ \Delta \aServo[3] \end{bmatrix}
 .
\end{align}
Note that $\PropForceStat$ cancels out in \eqref{eq:TriActuatorTransferFunction}, \ie $\GenForceTransferFunction$ is independent of it.

From the structure of $\GenForceTransferFunction$ in \eqref{eq:TriActuatorTransferFunction} it is clear that its entries are linear combinations of the transfer functions the the thrust and the servos, $\ThrustTransferFunction$ and $\ServoTransferFunction$.
Also it is evident that if $\ThrustTransferFunction = \ServoTransferFunction$, then $\GenForceTransferFunction$ would be diagonal.
Since this is not the case we do have off-diagonal entries in the transfer matrix $\GenForceTransferFunction$.
This so-called crosstalk between the components of the generalized force $\genForce$ depends mainly on the expansion point of the servo angles $\aServoStat$.

For a better quantitative analysis of the off-diagonal entries of $\GenForceTransferFunction$, the transfer function is normalized as $\GenForceTransferFunctionNorm = S^{-1} \GenForceTransferFunction S $ where $S = \diag(F_{\mathsf{x,Max}}, \ldots, \tau_{\mathsf{z,Max}})$ contains the maximal magnitudes of the corresponding forces and torques.
\autoref{fig:BodeTriActorDyn} shows exemplary the bode magnitude plot of $\GenForceTransferFunctionNorm$ for the hover case $\aServoStat = [0,0,0]^\top$ (left) and for a forward force with $\aServoStat = [\sfrac{\pi}{4},0,-\sfrac{\pi}{4}]^\top$ (right).
In the hover case the diagonal entries for $\Fz$, $\taux$ and $\tauy$ coincide with the thrust dynamics $\ThrustTransferFunction$, whereas the diagonal entries for $\Fx$ and $\Fy$ coincide with the servo dynamics $\ServoTransferFunction$.
The diagonal entry for $\tauz$ is dominated by the servo dynamics $\ServoTransferFunction$ but also has a small influence from $\ThrustTransferFunction$ due to the propeller drag (terms involving $\kappaT$ in \eqref{eq:TriActuatorTrafo}).
The propeller drag is also responsible for the small off-diagonal entries in the hover case.
For the forward force case it is evident that the diagonal entries are linear combinations of $\ThrustTransferFunction$ and $\ServoTransferFunction$.
Furthermore, the off-diagonal entries have a significantly larger magnitude.

\begin{figure}
 \centering
 \includegraphics{graphics/TriActuatorDynamics/BodeTriActorDyn.pdf}
 \caption{Bode magnitude plot of the normalized \Tricopter actuator dynamics transfer function $\GenForceTransferFunctionNorm$ at different expansion points}
 \label{fig:BodeTriActorDyn}
\end{figure}


\subsection{Quadcopter force vector control}
\paragraph{Model.}
The model of the generalized force on the quadcopter from \eqref{eq:QuadActuatorTrafo} can be split into a static part $\genForceQuadStat$, proportional to the squares of the propeller velocities $\PropVel$, and a dynamic part $\genForceQuadDyn$ proportional to the propeller accelerations $\PropVeld$, as
\begin{align}\label{eq:QuadForceVelctorModel}
% \underbrace{\begin{bmatrix} \Fz \\ \taux \\ \tauy \\ \tauz \end{bmatrix}}_{\genForceQuad}
 \genForceQuad(\PropVel, \PropVeld)
 =
 \underbrace{
 \overbrace{\begin{bmatrix}
  \kappaF & \kappaF & \kappaF & \kappaF \\
  0 & \kappaF\ArmRadius & 0 & -\kappaF\ArmRadius \\
  -\kappaF\ArmRadius & 0 & \kappaF\ArmRadius & 0 \\
  -\kappaT & \kappaT & -\kappaT & \kappaT \\
 \end{bmatrix}}^{B}
 %\underbrace{
 \begin{bmatrix} \PropVel[1]^2 \\ \PropVel[2]^2 \\ \PropVel[3]^2 \\ \PropVel[4]^2 \end{bmatrix}
 %}_{\PropForce[]}
 }_{\genForceQuadStat(\PropVel)}
 -
 \underbrace{\begin{bmatrix} 0 \\ 0 \\ 0 \\ \JP (\PropVeld[1] - \PropVeld[2] + \PropVeld[3] - \PropVeld[4]) \end{bmatrix}}_{\genForceQuadDyn(\PropVeld)}
 .
\end{align}

\paragraph{Filter dynamics.}
The task here is to design a filter which outputs the desired propeller velocities $\PropVel[][k]$ and $\PropVel[][k+1]$ for the next two sampling steps based on the given desired generalized force $\genForceQuadD[k]$.
Note that $\genForceQuad$ is \textit{not} a flat output of \eqref{eq:QuadForceVelctorModel}, so a simple low-pass filter for $\genForceQuadD$ does not do the trick.
However, the propeller velocities $\PropVel$ form a flat output and so we propose the following continuous time filter
\begin{align}\label{eq:QuadActuatorFilterDesign}
 \tfrac{\d^2}{\d t^2} \big(\genForceQuadStat(\PropVelDF)\big) + K_1 \tfrac{\d}{\d t} \big(\genForceQuadStat(\PropVelDF)\big) + K_0 \big( \genForceQuad(\PropVelDF,\PropVelDFd) - \genForceQuadD \big) = 0
 .
\end{align}
With introduction of the auxiliary state $\hat{h} = \tfrac{\d}{\d t} \big(\genForceQuadStat(\PropVelDF)\big) + K_1 \genForceQuadStat(\PropVelDF)$ this can be rewritten in an explicit first order form
\begin{subequations}\label{eq:QuadcopterActuatorFilter}
\begin{align}
 \PropVelDFd &= \diag(2 \kappaF \PropVelDF)^{-1} B^{-1} \big( \hat{h} - K_1 \genForceQuadStat(\PropVelDF) \big),
\\
 \dot{\hat{h}} &= K_0 \big( \genForceQuadD - \genForceQuad(\PropVelDF,\PropVelDFd) \big).
\end{align}
\end{subequations}
For the time discrete implementation we add the forward Euler approximation of the derivatives
\begin{align}\label{eq:QuadcopterActuatorFilterDiscretization}
 \PropVelDF[][k\!+\!1] = \PropVelDF[][k] + \Ts \PropVelDFd[][k],
\qquad
 \hat{h}[k\!+\!1] = \hat{h}[k] + \Ts \dot{\hat{h}}[k].
\end{align}
With this representation of the filter dynamics it is very simple to add a saturation $\PropVelMin \leq \PropVelDF \leq \PropVelMax$ to take into account the practical limitations of the propellers.
The combination of \eqref{eq:QuadcopterActuatorFilter} and \eqref{eq:QuadcopterActuatorFilterDiscretization} constitute a time discrete nonlinear system with the input $\genForceQuadD[k]$ and the output $\PropVelDF[][k]$, $\PropVelDF[][k+1]$, the \textit{quadcopter actuator dynamics}.  

\paragraph{Tuning.}
The filter gains $K_1$ and $K_2$ are chosen as diagonal matrices and for symmetry considerations the gains corresponding to $\taux$ and $\tauy$ are identical, \ie
\begin{align}
 K_0 = \diag(\kPMag, \kPTilt, \kPTilt, \kPHead),
\qquad
 K_1 = \diag(\kDMag, \kDTilt, \kDTilt, \kDHead).
\end{align}
For a quantitative analysis of the actuator dynamics we consider its linearization for a general expansion point $(\PropVelStat[1], \ldots, \PropVelStat[4]) \in [\PropVelMin, \PropVelMax]^4$.
Using the $z$-transformation we get the following transfer matrix 
\begin{align}
 \ZTrafo{\Delta \genForce} = \GenForceTransferFunction(z) \, \ZTrafo{\Delta \genForceD},
\qquad
 \GenForceTransferFunction(z) =
 \begin{bmatrix}
  G_{11}(z) & 0 & 0 & 0 \\
  0 & G_{22}(z) & 0 & 0 \\
  0 & 0 & G_{33}(z) & 0 \\
  G_{41}(z) & G_{42}(z) & G_{43}(z) & G_{44}(z) \\
 \end{bmatrix}
\end{align}
with the components
\begin{subequations}\label{eq:QuadActuatorDynTransferComponents}
\begin{align}
% G_{11}(z) &= \frac{\kPMag\Ts^2}{(z-1)^2 + \kDMag\Ts (z-1) + \kPMag\Ts^2}
 G_{11}(z) &= \frac{\kPMag}{\big(\tfrac{z-1}{\Ts}\big)^2 + \kDMag \tfrac{z-1}{\Ts} + \kPMag}
\\
 G_{22}(z) = G_{33}(z) &= \frac{\kPTilt}{\big(\tfrac{z-1}{\Ts}\big)^2 + \kDTilt \tfrac{z-1}{\Ts} + \kPTilt}
\\
 G_{44}(z) &= \frac{\kPHead(p_4\tfrac{z-1}{\Ts} + 1)}{\big(\tfrac{z-1}{\Ts}\big)^2 + (\kPHead p_4 + \kDTilt) \tfrac{z-1}{\Ts} + \kPHead}
\\
 G_{4j}(z) &= \frac{p_j\,G_{jj}(z)\,\big(\tfrac{z-1}{\Ts}\big)^2 (\tfrac{z-1}{\Ts} + \kDHead)}{\big(\tfrac{z-1}{\Ts}\big)^2 + (\kPHead p_4 + \kDTilt) \tfrac{z-1}{\Ts} + \kPHead}, \quad j=1,2,3
\end{align}
\end{subequations}
and the (expansion point dependent) model parameters
\begin{subequations}
\begin{align}
 p_1 &= \tfrac{\PropInertia}{8\kappaF} \left( \tfrac{1}{\PropVelStat[4]} - \tfrac{1}{\PropVelStat[3]} + \tfrac{1}{\PropVelStat[2]} - \tfrac{1}{\PropVelStat[1]} \right),&
 p_2 &= \tfrac{\PropInertia}{4\kappaF\ArmRadius} \left( \tfrac{1}{\PropVelStat[2]} - \tfrac{1}{\PropVelStat[4]} \right),
\\
 p_4 &= \tfrac{\PropInertia}{8\kappaT} \left( \tfrac{1}{\PropVelStat[1]} + \tfrac{1}{\PropVelStat[2]} + \tfrac{1}{\PropVelStat[3]} + \tfrac{1}{\PropVelStat[4]} \right),&
 p_3 &= \tfrac{\PropInertia}{4\kappaF\ArmRadius} \left( \tfrac{1}{\PropVelStat[1]} - \tfrac{1}{\PropVelStat[3]} \right).
\end{align}
\end{subequations}
The transfer behaviors for $\Fz$, $\taux$ and $\tauy$ are uncorrelated and independent of the expansion point.
Their parameters are chosen to form a second order Butterworth filter.

Unfortunately, the transfer behavior for $\tauz$ is not that nice:
It is in general affected by all components of $\genForceD$ and the corresponding transfer functions $G_{4j}, j=1,\ldots,4$ depend on the expansion point.
However, for the hover case $\PropVelStat[1] = \PropVelStat[2] = \PropVelStat[3] = \PropVelStat[4] = \sqrt{\sfrac{m \gravityAccConst}{4\kappaF}}$ we have $p_1=p_2=p_3=0$ and $p_4 = \tfrac{\PropInertia}{\kappaT}\sqrt{\sfrac{\kappaF}{m \gravityAccConst}}$.
We choose $\kDHead = \sfrac{1}{p_4} = \tfrac{\kappaT}{\PropInertia}\sqrt{\sfrac{m \gravityAccConst}{\kappaF}}$ such that \textit{at this particular expansion point} we have a pole-zero cancellation.
The remaining parameter $\kPHead$ is then used to adjust the cut-off frequency of the filter.

\autoref{fig:BodeQuadActorDyn} shows the Bode magnitude plot of the normalized transfer matrix $\GenForceTransferFunctionNorm$ coefficients from \eqref{eq:QuadActuatorDynTransferComponents} with the used filter parameters.
The left side corresponds to the most common hover case $\PropVelStat[1] = \PropVelStat[2] = \PropVelStat[3] = \PropVelStat[4] = \sqrt{\sfrac{m \gravityAccConst}{4\kappaF}}$ whereas the right side captures the ``worst case`` expansion points where $(\PropVelStat[1], \ldots,\PropVelStat[4]) \in \{ \PropVelMin, \PropVelMax\}^4$.
Obviously the pole-zero cancellation only holds for the hover case but even for the worst case points $G_{44}$ only differs slightly from its design.
Furthermore one can see that the influence of the off-diagonal entries is restricted to high frequencies.

\begin{figure}[ht]
 \centering
 \includegraphics{graphics/QuadActuatorDynamics/BodeQuadActorDyn.pdf}
 \caption{Bode magnitude plot of the normalized transfer matrix $\GenForceTransferFunctionNorm$ at different expansion points}
 \label{fig:BodeQuadActorDyn}
\end{figure}

\paragraph{Comparison to static approach.}
The proposed filter \eqref{eq:QuadActuatorFilterDesign} might seem complicated.
In particular one might argue that the dynamic part $\genForceQuadDyn$ in the model \eqref{eq:QuadForceVelctorModel} is neglectable, as is done in most publications on this subject.

To answer this question we can replace \eqref{eq:QuadActuatorFilterDesign} by
\begin{align}\label{eq:QuadActuatorFilterDesignTraditional}
 \tfrac{\d^2}{\d t^2} \big(\genForceQuadStat(\PropVelDF)\big) + K_1 \tfrac{\d}{\d t} \big(\genForceQuadStat(\PropVelDF)\big) + K_0 \big( \genForceQuadStat(\PropVelDF) - \genForceQuadD \big) = 0
\end{align}
what essentially neglects the dynamics part $\genForceQuadDyn$ in the generalized force $\genForceQuad = \genForceQuadStat + \genForceQuadDyn$.
As before we now consider the transfer matrix $\GenForceTransferFunction$ for the linearized filter at a general expansion point.
The components differing from \eqref{eq:QuadActuatorDynTransferComponents} are
\begin{align}\label{eq:QuadActuatorDynTransferTraditionalComponents}
 G_{44}(z) = \frac{\kPHead(p_4\tfrac{z-1}{\Ts} + 1)}{\big(\tfrac{z-1}{\Ts}\big)^2 + \kDTilt \tfrac{z-1}{\Ts} + \kPHead}
\qquad
 G_{4j}(z) = p_j\,\tfrac{z-1}{\Ts}\,G_{jj}(z), \ j=1,2,3.
\end{align}
Now one can chose the gains $K_0$ and $K_1$ such that \eqref{eq:QuadActuatorFilterDesignTraditional} forms 4 decoupled second order Butterworth filters with inputs $\genForceQuadD$ and outputs $\genForceQuadStat$.
However, since the real force on the quadcopter does contain the dynamic part as well the behavior from $\genForceQuadD$ to $\genForceQuad = \genForceQuadStat + \genForceQuadDyn$ is quite different, as can be seen in \eqref{eq:QuadActuatorDynTransferTraditionalComponents}.
The Bode magnitude plot of the transfer functions is displayed in \autoref{fig:BodeQuadActorDynTraditional} on the left side.
Even for the hover case (thick lines) the transfer function $G_{44}$ for $\tauz$ has an unacceptable overshot.

In oder to improve the behavior we can do the same as before: adjust the parameters in $G_{44}$, \ie $\kPHead$ and $\kDHead$, such that there is a pole-zero cancelation at the hover expansion point.
The resulting Bode magnitude plot is shown on the right side of \autoref{fig:BodeQuadActorDynTraditional}.
It is already a significant improvement compared to the right side but is much worse as the previous result shown in \autoref{fig:BodeQuadActorDyn}.
Moreover, the magnitude of the off-diagonal transfer functions at low frequencies is much higher for both cases in \autoref{fig:BodeQuadActorDynTraditional} than in \autoref{fig:BodeQuadActorDyn}.

\begin{figure}[ht]
 \centering
 \includegraphics{graphics/QuadActuatorDynamics/BodeQuadActorDynTraditional.pdf}
 \caption{Bode magnitude plot of the normalized transfer matrix $\GenForceTransferFunctionNorm$ at different expansion points (static approach)}
 \label{fig:BodeQuadActorDynTraditional}
\end{figure}

Overall this discussion should justify the filter design in \eqref{eq:QuadActuatorFilterDesign} and justify the consideration of the dynamic model \eqref{eq:QuadForceVelctorModel} for the present case.
For other quadcopters with smaller ratios $\sfrac{\PropInertia}{\kappaT}$ or less aggressively tuned multicopters like the previously discussed tricopter, however, the situation can be different.
